<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>xanespy package</title>
    
    <link rel="stylesheet" href="_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> 
  </head>
  <body role="document">

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="xanespy-package">
<h1>xanespy package</h1>
<div class="section" id="submodules">
<h2>Submodules</h2>
</div>
<div class="section" id="module-xanespy.beamlines">
<span id="xanespy-beamlines-module"></span><h2>xanespy.beamlines module</h2>
<p>Functions and classes that prepare experiments at specific
synchrotron beamlines.</p>
<dl class="class">
<dt id="xanespy.beamlines.Detector">
<em class="property">class </em><code class="descclassname">xanespy.beamlines.</code><code class="descname">Detector</code><span class="sig-paren">(</span><em>start: xanespy.beamlines.ZoneplatePoint</em>, <em>z_step: int = None</em>, <em>end: xanespy.beamlines.ZoneplatePoint = None</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.beamlines.Zoneplate" title="xanespy.beamlines.Zoneplate"><code class="xref py py-class docutils literal"><span class="pre">xanespy.beamlines.Zoneplate</span></code></a></p>
<p>A calibration object for the position of the detector.</p>
</dd></dl>

<dl class="class">
<dt id="xanespy.beamlines.DetectorPoint">
<em class="property">class </em><code class="descclassname">xanespy.beamlines.</code><code class="descname">DetectorPoint</code><span class="sig-paren">(</span><em>z</em>, <em>energy</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<dl class="attribute">
<dt id="xanespy.beamlines.DetectorPoint.energy">
<code class="descname">energy</code></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.beamlines.DetectorPoint.z">
<code class="descname">z</code></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.beamlines.Zoneplate">
<em class="property">class </em><code class="descclassname">xanespy.beamlines.</code><code class="descname">Zoneplate</code><span class="sig-paren">(</span><em>start: xanespy.beamlines.ZoneplatePoint</em>, <em>z_step: int = None</em>, <em>end: xanespy.beamlines.ZoneplatePoint = None</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Type of focusing optic using in X-ray microscopy. It must be moved
with changing energy to properly focus the beam. In order to
properly predict zoneplate positions, it needs either two
position-energy pairs or one position-energy pair and a
step. Passing two position-energy pairs is preffered because this
allows x, y and z to be set properly instead of just z.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start</strong> (<em>-</em>) &#8211; </li>
<li><strong>z_step</strong> (<em>-</em>) &#8211; of beam energy.</li>
<li><strong>end</strong> (<em>-</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="xanespy.beamlines.Zoneplate.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>energy: float</em><span class="sig-paren">)</span></dt>
<dd><p>Predict the x, y and z position of the zonplate for the given energy.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.beamlines.ZoneplatePoint">
<em class="property">class </em><code class="descclassname">xanespy.beamlines.</code><code class="descname">ZoneplatePoint</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>energy</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<dl class="attribute">
<dt id="xanespy.beamlines.ZoneplatePoint.energy">
<code class="descname">energy</code></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.beamlines.ZoneplatePoint.x">
<code class="descname">x</code></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.beamlines.ZoneplatePoint.y">
<code class="descname">y</code></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.beamlines.ZoneplatePoint.z">
<code class="descname">z</code></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="xanespy.beamlines.sector8_xanes_script">
<code class="descclassname">xanespy.beamlines.</code><code class="descname">sector8_xanes_script</code><span class="sig-paren">(</span><em>dest, edge: edges.KEdge, zoneplate: xanespy.beamlines.Zoneplate, detector: xanespy.beamlines.Detector, sample_positions: typing.List[utilities.position], names: typing.List[str], iterations: typing.Iterable = range(0, 1), binning: int = 1, exposure: int = 30, abba_mode: bool = True</em><span class="sig-paren">)</span></dt>
<dd><p>Prepare an script file for running multiple consecutive XANES
framesets on the transmission x-ray micrscope at the Advanced
Photon Source beamline 8-BM-B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dest</strong> (<em>-</em>) &#8211; </li>
<li><strong>edge</strong> (<em>-</em>) &#8211; </li>
<li><strong>binning</strong> (<em>-</em>) &#8211; (eg. 2 means 2x2 CCD pixels become 1 image pixel.</li>
<li><strong>exposure</strong> (<em>-</em>) &#8211; </li>
<li><strong>sample_positions</strong> (<em>-</em>) &#8211; order to capture the image.</li>
<li><strong>zoneplate</strong> (<em>-</em>) &#8211; </li>
<li><strong>detector</strong> (<em>-</em>) &#8211; </li>
<li><strong>names</strong> (<em>-</em>) &#8211; </li>
<li><strong>iterations</strong> (<em>-</em>) &#8211; set of xanes location with reference.</li>
<li><strong>abba_mode</strong> (<em>-</em>) &#8211; to save time. Eg: reference, sample, change-energy, sample,
reference, change-energy, etc. Not compatible with <cite>frame_rest</cite>
argument.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.beamlines.ssrl6_xanes_script">
<code class="descclassname">xanespy.beamlines.</code><code class="descname">ssrl6_xanes_script</code><span class="sig-paren">(</span><em>dest, edge: edges.KEdge, zoneplate: xanespy.beamlines.Zoneplate, positions: typing.List[utilities.position], reference_position: utilities.position, iterations: typing.Iterable, iteration_rest: int = 0, frame_rest: int = 0, binning: int = 2, exposure: int = 0.5, repetitions: int = 5, ref_repetitions: int = 10, abba_mode: bool = True</em><span class="sig-paren">)</span></dt>
<dd><p>Prepare a script file for running multiple consecutive XANES
framesets on the transmission x-ray micrscope at the Advanced
Photon Source beamline 8-BM-B. Both <cite>iteration_rest</cite> and
<cite>frame_rest</cite> can be used to give the material time to recover from
X-ray damage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dest</strong> (<em>-</em>) &#8211; </li>
<li><strong>edge</strong> (<em>-</em>) &#8211; </li>
<li><strong>binning</strong> (<em>-</em>) &#8211; (eg. 2 means 2x2 CCD pixels become 1 image pixel.</li>
<li><strong>exposure</strong> (<em>-</em>) &#8211; </li>
<li><strong>positions</strong> (<em>-</em>) &#8211; order to capture the image.</li>
<li><strong>reference_position</strong> (<em>-</em>) &#8211; reference frame.</li>
<li><strong>iteration_rest</strong> (<em>-</em>) &#8211; iterations. Beam will wait at reference location before starting
next XANES set.</li>
<li><strong>frame_rest</strong> (<em>-</em>) &#8211; wait at reference location before starting next energy frame.</li>
<li><strong>zoneplate</strong> (<em>-</em>) &#8211; </li>
<li><strong>detector</strong> (<em>-</em>) &#8211; </li>
<li><strong>iterations</strong> (<em>-</em>) &#8211; </li>
<li><strong>repetitions</strong> (<em>-</em>) &#8211; location/energy. These frames will then be averaged during
analysis.</li>
<li><strong>ref_repetitions</strong> (<em>-</em>) &#8211; </li>
<li><strong>abba_mode</strong> (<em>-</em>) &#8211; locations first to save time. Eg: reference, sample,
change-energy, sample, reference, change-energy, etc. Not
compatible with <cite>frame_rest</cite> argument.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.beamlines.write_scaninfo_header">
<code class="descclassname">xanespy.beamlines.</code><code class="descname">write_scaninfo_header</code><span class="sig-paren">(</span><em>f</em>, <em>abba_mode</em>, <em>repetitions</em>, <em>ref_repetitions</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-xanespy.edges">
<span id="xanespy-edges-module"></span><h2>xanespy.edges module</h2>
<p>Descriptions of X-ray energy absorption edge.</p>
<dl class="class">
<dt id="xanespy.edges.Edge">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">Edge</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An X-ray absorption edge. It is defined by a series of energy
ranges. All energies are assumed to be in units of
electron-volts. This class is intended to be extended into K-edge,
L-edge, etc.</p>
<dl class="attribute">
<dt id="xanespy.edges.Edge.E_0">
<code class="descname">E_0</code></dt>
<dd><p><em>float</em> &#8211; The energy of the absorption edge itself.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.regions">
<code class="descname">regions</code></dt>
<dd><p><em>list of 3-tuples</em> &#8211; All the energy regions. Each tuple is of the form (start, end,
step) and is inclusive at both ends.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.name">
<code class="descname">name</code></dt>
<dd><p><em>string</em> &#8211; A human-readable name for this edge (eg &#8220;Ni K-edge&#8221;)</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.pre_edge">
<code class="descname">pre_edge</code></dt>
<dd><p><em>2-tuple</em> &#8211; Energy range (start, stop) that defines points below the edge
region, inclusive.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.post_edge">
<code class="descname">post_edge</code></dt>
<dd><p><em>2-tuple</em> &#8211; Energy range (start, stop) that defines points above the edge
region, inclusive.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.post_edge_order">
<code class="descname">post_edge_order</code></dt>
<dd><p><em>int</em> &#8211; What degree polynomial to use for fitting the post_edge region.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.map_range">
<code class="descname">map_range</code></dt>
<dd><p><em>2-tuple</em> &#8211; Energy range (start, stop) used for normalizing maps. If not
supplied, will be determine from pre- and post-edge arguments.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.edge_range">
<code class="descname">edge_range</code></dt>
<dd><p><em>2-tuple</em> &#8211; Energy range (start, stop) used to determine the official
beginning and edge of the edge itself.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">E_0</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.edges.Edge.all_energies">
<code class="descname">all_energies</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">edge_range</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.edges.Edge.energies_in_range">
<code class="descname">energies_in_range</code><span class="sig-paren">(</span><em>norm_range=None</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">map_range</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">post_edge</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">post_edge_order</code><em class="property"> = 2</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">pre_edge</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.Edge.pre_edge_fit">
<code class="descname">pre_edge_fit</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">regions</code><em class="property"> = []</em></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.KEdge">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">KEdge</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.Edge" title="xanespy.edges.Edge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.Edge</span></code></a></p>
<p>An X-ray absorption K-edge corresponding to a 1s transition.</p>
<dl class="method">
<dt id="xanespy.edges.KEdge.annotate_spectrum">
<code class="descname">annotate_spectrum</code><span class="sig-paren">(</span><em>ax</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.edges.KEdge.mask">
<code class="descname">mask</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Return a numpy array mask for material that&#8217;s active at this
edge. Calculations are done in <cite>xanes_math.l_edge_mask()</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.LEdge">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">LEdge</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.Edge" title="xanespy.edges.Edge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.Edge</span></code></a></p>
<p>An X-ray absorption K-edge corresponding to a 2s or 2p
transition.</p>
<dl class="method">
<dt id="xanespy.edges.LEdge.annotate_spectrum">
<code class="descname">annotate_spectrum</code><span class="sig-paren">(</span><em>ax</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.edges.LEdge.mask">
<code class="descname">mask</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Return a numpy array mask for material that&#8217;s active at this
edge. Calculations are done in <cite>xanes_math.l_edge_mask()</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.LMOMnKEdge">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">LMOMnKEdge</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.KEdge" title="xanespy.edges.KEdge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.KEdge</span></code></a></p>
<dl class="attribute">
<dt id="xanespy.edges.LMOMnKEdge.regions">
<code class="descname">regions</code><em class="property"> = [(6450, 6510, 20), (6524, 6542, 2), (6544, 6564, 1), (6566, 6568, 2), (6572, 6600, 4), (6610, 6650, 10), (6700, 6850, 50)]</em></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.NCACobaltLEdge">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">NCACobaltLEdge</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.LEdge" title="xanespy.edges.LEdge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.LEdge</span></code></a></p>
<dl class="attribute">
<dt id="xanespy.edges.NCACobaltLEdge.E_0">
<code class="descname">E_0</code><em class="property"> = 793.2</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCACobaltLEdge.map_range">
<code class="descname">map_range</code><em class="property"> = (0, 1)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCACobaltLEdge.post_edge">
<code class="descname">post_edge</code><em class="property"> = (785, 790)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCACobaltLEdge.pre_edge">
<code class="descname">pre_edge</code><em class="property"> = (770, 775)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCACobaltLEdge.regions">
<code class="descname">regions</code><em class="property"> = [(770, 775, 1), (775, 785, 0.5), (785, 790, 1)]</em></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.NCANickelKEdge">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">NCANickelKEdge</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.KEdge" title="xanespy.edges.KEdge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.KEdge</span></code></a></p>
<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge.E_0">
<code class="descname">E_0</code><em class="property"> = 8333</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge.edge_range">
<code class="descname">edge_range</code><em class="property"> = (8341, 8358)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge.map_range">
<code class="descname">map_range</code><em class="property"> = (8341, 8358)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge.post_edge">
<code class="descname">post_edge</code><em class="property"> = (8440, 8640)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge.pre_edge">
<code class="descname">pre_edge</code><em class="property"> = (8249, 8281)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge.regions">
<code class="descname">regions</code><em class="property"> = [(8250, 8310, 20), (8324, 8344, 2), (8344, 8356, 1), (8356, 8360, 2), (8360, 8400, 4), (8400, 8440, 8), (8440, 8640, 50)]</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge.shell">
<code class="descname">shell</code><em class="property"> = 'K'</em></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.NCANickelKEdge61">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">NCANickelKEdge61</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.NCANickelKEdge" title="xanespy.edges.NCANickelKEdge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.NCANickelKEdge</span></code></a></p>
<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge61.regions">
<code class="descname">regions</code><em class="property"> = [(8250, 8310, 15), (8324, 8360, 1), (8360, 8400, 4), (8400, 8440, 8), (8440, 8640, 50)]</em></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.NCANickelKEdge62">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">NCANickelKEdge62</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.NCANickelKEdge" title="xanespy.edges.NCANickelKEdge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.NCANickelKEdge</span></code></a></p>
<dl class="attribute">
<dt id="xanespy.edges.NCANickelKEdge62.regions">
<code class="descname">regions</code><em class="property"> = [(8250, 8310, 15), (8324, 8360, 1), (8360, 8400, 4), (8400, 8440, 8), (8440, 8690, 50)]</em></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.edges.NCANickelLEdge">
<em class="property">class </em><code class="descclassname">xanespy.edges.</code><code class="descname">NCANickelLEdge</code></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.edges.LEdge" title="xanespy.edges.LEdge"><code class="xref py py-class docutils literal"><span class="pre">xanespy.edges.LEdge</span></code></a></p>
<dl class="attribute">
<dt id="xanespy.edges.NCANickelLEdge.E_0">
<code class="descname">E_0</code><em class="property"> = 853</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelLEdge.map_range">
<code class="descname">map_range</code><em class="property"> = (0, 1)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelLEdge.post_edge">
<code class="descname">post_edge</code><em class="property"> = (857, 862)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelLEdge.pre_edge">
<code class="descname">pre_edge</code><em class="property"> = (844, 848)</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.edges.NCANickelLEdge.regions">
<code class="descname">regions</code><em class="property"> = [(844, 848, 1), (849, 856, 0.25), (857, 862, 1)]</em></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy.exceptions">
<span id="xanespy-exceptions-module"></span><h2>xanespy.exceptions module</h2>
<p>Define classes for more fine-grained control over exception
handling.</p>
<dl class="exception">
<dt id="xanespy.exceptions.CreateGroupError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">CreateGroupError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></p>
<p>Tried to import a TXM frameset into a group but the corresponding
HDF group already exists or is otherwise inaccessible.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.DataFormatError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">DataFormatError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></code></p>
<p>The raw data are arranged in a way that the importers or TXM classes do
not understand.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.DataNotFoundError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">DataNotFoundError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">FileNotFoundError</span></code></p>
<p>Expected a directory containing data but found none.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.DatasetExistsError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">DatasetExistsError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></code></p>
<p>Trying to save a new dataset but one already exists with the given
path.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.FileExistsError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">FileExistsError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">OSError</span></code></p>
<p>Tried to import a TXM frameset but the corresponding HDF file
already exists.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.FilenameParseError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">FilenameParseError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></p>
<p>The parameters in the filename do not match the naming scheme
associated with this flavor.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.FrameFileNotFound">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">FrameFileNotFound</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">OSError</span></code></p>
<p>Expected to load a TXM frame file but it doesn&#8217;t exist.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.GroupKeyError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">GroupKeyError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">KeyError</span></code></p>
<p>Tried to load or create an HDF group but failed. Examples include:
the group doesn&#8217;t exist, is ambiguous or already exists when being
created.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.HDFScopeError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">HDFScopeError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></p>
<p>Tried to pass an HDF scope that is not recognized.</p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.NoParticleError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">NoParticleError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.RefinementError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">RefinementError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></code></p>
</dd></dl>

<dl class="exception">
<dt id="xanespy.exceptions.XanesMathError">
<em class="property">exception </em><code class="descclassname">xanespy.exceptions.</code><code class="descname">XanesMathError</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></code></p>
</dd></dl>

</div>
<div class="section" id="module-xanespy.importers">
<span id="xanespy-importers-module"></span><h2>xanespy.importers module</h2>
<dl class="function">
<dt id="xanespy.importers.decode_aps_params">
<code class="descclassname">xanespy.importers.</code><code class="descname">decode_aps_params</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></dt>
<dd><p>Accept the filename of an XRM file and return sample parameters as
a dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.importers.decode_ssrl_params">
<code class="descclassname">xanespy.importers.</code><code class="descname">decode_ssrl_params</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></dt>
<dd><p>Accept the filename of an XRM file and return sample parameters as
a dictionary.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.importers.import_aps_8BM_frameset">
<code class="descclassname">xanespy.importers.</code><code class="descname">import_aps_8BM_frameset</code><span class="sig-paren">(</span><em>directory</em>, <em>hdf_filename</em>, <em>quiet=False</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="xanespy.importers.import_frameset">
<code class="descclassname">xanespy.importers.</code><code class="descname">import_frameset</code><span class="sig-paren">(</span><em>directory</em>, <em>flavor</em>, <em>hdf_filename</em><span class="sig-paren">)</span></dt>
<dd><p>Import all files in the given directory collected at an X-ray
microscope beamline.</p>
<p>Images are assumed to full-field transmission X-ray micrographs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>directory</strong> (<em>str</em>) &#8211; A valid path to a directory containing the frame data to import.</li>
<li><strong>flavor</strong> (<em>str</em>) &#8211; Indicates what type of naming conventions and data structure to
assume. See documentation for <code class="docutils literal"><span class="pre">xanespy.xradia.XRMFile</span></code> for
possible choice.</li>
<li><strong>hdf_filename</strong> (<em>str</em>) &#8211; Where to save the output to. An exception is throw if this file
already exists.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.importers.import_nanosurveyor_frameset">
<code class="descclassname">xanespy.importers.</code><code class="descname">import_nanosurveyor_frameset</code><span class="sig-paren">(</span><em>directory: str</em>, <em>quiet=False</em>, <em>hdf_filename=None</em>, <em>hdf_groupname=None</em>, <em>energy_range=None</em>, <em>exclude_re=None</em>, <em>append=False</em><span class="sig-paren">)</span></dt>
<dd><p>Import a set of images from reconstructed ptychography scanning microscope data.</p>
<p>This generates ptychography chemical maps based on data collected at ALS beamline
5.3.2.1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>directory</strong> (<em>str</em>) &#8211; Directory where to look for results. It should contain .cxi
files that are the output of the ptychography reconstruction.&#8221;</li>
<li><strong>quiet</strong> (<em>Bool</em><em>, </em><em>optional</em>) &#8211; If truthy, progress bars will not be shown.</li>
<li><strong>hdf_filename</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; HDF File used to store computed results. If omitted or None, the
<cite>directory</cite> basename is used</li>
<li><strong>hdf_groupname</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Name to use for the hdf group of this dataset. If omitted or
None, the <cite>directory</cite> basename is used. Raises an exception if
the group already exists in the HDF file.</li>
<li><strong>energy_range</strong> (<em>2-tuple</em><em>, </em><em>optional</em>) &#8211; A 2-tuple with the (min, max) energy to be imported. This is
useful if only a subset of the available data is usable. Values
are assumed to be in electron-volts.</li>
<li><strong>exclude_re</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Any filenames matching this regular expression will not be
imported. A string or compiled re object can be given.</li>
<li><strong>append</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If True, any existing dataset will be added to, rather
than replaced (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.importers.import_ssrl_frameset">
<code class="descclassname">xanespy.importers.</code><code class="descname">import_ssrl_frameset</code><span class="sig-paren">(</span><em>directory</em>, <em>hdf_filename=None</em><span class="sig-paren">)</span></dt>
<dd><p>Import all files in the given directory collected at SSRL beamline
6-2c and process into framesets. Images are assumed to full-field
transmission X-ray micrographs and repetitions will be
averaged. Passed on to <code class="docutils literal"><span class="pre">xanespy.importers.import_frameset</span></code></p>
</dd></dl>

<dl class="function">
<dt id="xanespy.importers.magnification_correction">
<code class="descclassname">xanespy.importers.</code><code class="descname">magnification_correction</code><span class="sig-paren">(</span><em>frames</em>, <em>pixel_sizes</em><span class="sig-paren">)</span></dt>
<dd><p>Correct for changes in magnification at different energies.</p>
<p>As the X-ray energy increases, the focal length of the zone plate
changes and so the image is zoomed-out at higher energies. This
method applies a correction to each frame to make the
magnification similar to that of the first frame. Some beamlines
correct for this automatically during acquisition and don&#8217;t need
this function: APS 8-BM-B, 32-ID-C.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>np.ndarray</em>) &#8211; Numpy array of image frames that need to be corrected.</li>
<li><strong>pixel_sizes</strong> (<em>np.ndarray</em>) &#8211; Numpy array of pixel sizes corresponding to entries in <cite>frames</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>(scales2D, translations)</strong> &#8211; An array of scale factors to use for applying a correction to
each frame. Translations show how much to move each frame array by to re-center it.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(np.ndarray, np.ndarray)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.importers.read_metadata">
<code class="descclassname">xanespy.importers.</code><code class="descname">read_metadata</code><span class="sig-paren">(</span><em>filenames</em>, <em>flavor</em><span class="sig-paren">)</span></dt>
<dd><p>Take a list of filenames and return a pandas dataframe with all the
metadata.</p>
</dd></dl>

</div>
<div class="section" id="module-xanespy.plots">
<span id="xanespy-plots-module"></span><h2>xanespy.plots module</h2>
<p>Helper functions for setting up and displaying plots using matplotlib.</p>
<dl class="function">
<dt id="xanespy.plots.big_axes">
<code class="descclassname">xanespy.plots.</code><code class="descname">big_axes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return a new Axes object, but larger than the default.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.draw_colorbar">
<code class="descclassname">xanespy.plots.</code><code class="descname">draw_colorbar</code><span class="sig-paren">(</span><em>ax</em>, <em>cmap</em>, <em>norm</em>, <em>energies</em>, <em>orientation='vertical'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Draw a colorbar on the side of a mapping axes to show the range of
colors used. Returns the newly created colorbar object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ax</strong> (<em>-</em>) &#8211; </li>
<li><strong>cmap</strong> (<em>-</em>) &#8211; to use.</li>
<li><strong>norm</strong> (<em>-</em>) &#8211; use.</li>
<li><strong>energies</strong> (<em>-</em>) &#8211; colorbar.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.draw_histogram_colorbar">
<code class="descclassname">xanespy.plots.</code><code class="descname">draw_histogram_colorbar</code><span class="sig-paren">(</span><em>ax</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Similar to <cite>draw_colorbar()</cite> with some special formatting options
to put it along the X-axis of the axes.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.dual_axes">
<code class="descclassname">xanespy.plots.</code><code class="descname">dual_axes</code><span class="sig-paren">(</span><em>fig=None</em>, <em>orientation='horizontal'</em><span class="sig-paren">)</span></dt>
<dd><p>Two new axes for mapping, side-by-side.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.new_axes">
<code class="descclassname">xanespy.plots.</code><code class="descname">new_axes</code><span class="sig-paren">(</span><em>height=5</em>, <em>width=None</em><span class="sig-paren">)</span></dt>
<dd><p>Create a new set of matplotlib axes for plotting. Height in inches.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.new_image_axes">
<code class="descclassname">xanespy.plots.</code><code class="descname">new_image_axes</code><span class="sig-paren">(</span><em>height=5</em>, <em>width=5</em><span class="sig-paren">)</span></dt>
<dd><p>Square axes with ticks on the outside.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.plot_composite_map">
<code class="descclassname">xanespy.plots.</code><code class="descname">plot_composite_map</code><span class="sig-paren">(</span><em>data</em>, <em>ax=None</em>, <em>origin='lower'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Plot an RGB composite map on the given axes.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.plot_pixel_spectra">
<code class="descclassname">xanespy.plots.</code><code class="descname">plot_pixel_spectra</code><span class="sig-paren">(</span><em>pixels</em>, <em>extent</em>, <em>spectra</em>, <em>energies</em>, <em>map_ax</em>, <em>spectra_ax=None</em>, <em>step_size=0</em><span class="sig-paren">)</span></dt>
<dd><p>Highlight certain pixels in an already-plotted map and plot their
spectra. The map should already have been plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pixels</strong> (<em>-</em>) &#8211; to highlight and plot.</li>
<li><strong>extent</strong> (<em>-</em>) &#8211; positions to (row, column) positions.</li>
<li><strong>spectra</strong> (<em>-</em>) &#8211; in <cite>pixels</cite> will use this array to get spectra. Shape is assumed
to be (row, column, energy).</li>
<li><strong>energies</strong> (<em>-</em>) &#8211; plotting spectra.</li>
<li><strong>map_ax</strong> (<em>-</em>) &#8211; pixels.</li>
<li><strong>spectra_ax</strong> (<em>-</em>) &#8211; None (default) a new axes will be created.</li>
<li><strong>step_size</strong> (<em>-</em>) &#8211; directly on top of each other.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.plot_txm_histogram">
<code class="descclassname">xanespy.plots.</code><code class="descname">plot_txm_histogram</code><span class="sig-paren">(</span><em>data</em>, <em>ax=None</em>, <em>norm=None</em>, <em>bins=None</em>, <em>cmap='plasma'</em>, <em>add_cbar=True</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Take an array of data values and show a histogram with some
color-coding related to normalization value.</p>
<p>Returns: The matplotlib axes object used for plotting.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>np.ndarray</em>) &#8211; An array of values to plot on the histogram.</li>
<li><strong>ax</strong> (<em>optional</em>) &#8211; Matplotlib Axes instance to receive the plot. If None, a new axes
will created.</li>
<li><strong>norm</strong> (<em>optional</em>) &#8211; Matplotlib Normalize instance with the colormap range.</li>
<li><strong>bins</strong> (<em>optional</em>) &#8211; Bins to pass to the matplotlib hist() routine. If None
(default), we will choose based on dtype of the data: integers
will yield 1-wide bins, anything else will give 256 bins.</li>
<li><strong>cmap</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Matplotlib colormap for coloring the bars.</li>
<li><strong>add_cbar</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; Boolean to decide whether to add a colorbar along the
bottom axis or not.</li>
<li><strong>*args</strong> &#8211; Positional arguments passed to matplotlib&#8217;s <cite>hist</cite> call.</li>
<li><strong>*kwargs</strong> &#8211; Keyword arguments passed to matplotlib&#8217;s <cite>hist</cite> call.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.plot_txm_intermediates">
<code class="descclassname">xanespy.plots.</code><code class="descname">plot_txm_intermediates</code><span class="sig-paren">(</span><em>images</em><span class="sig-paren">)</span></dt>
<dd><p>Accept a dictionary of images and plots them each on its own axes
using matplotlib&#8217;s <cite>imshow</cite>. This is a complement to routines that
operate on a microscopy frame and optionally return all the
intermediate calculated frames.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.plot_txm_map">
<code class="descclassname">xanespy.plots.</code><code class="descname">plot_txm_map</code><span class="sig-paren">(</span><em>data</em>, <em>edge=None</em>, <em>norm=None</em>, <em>ax=None</em>, <em>cmap='plasma'</em>, <em>origin='upper'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="xanespy.plots.plot_xanes_spectrum">
<code class="descclassname">xanespy.plots.</code><code class="descname">plot_xanes_spectrum</code><span class="sig-paren">(</span><em>spectrum</em>, <em>energies</em>, <em>norm=&lt;matplotlib.colors.Normalize object&gt;</em>, <em>show_fit=False</em>, <em>ax=None</em>, <em>ax2=None</em>, <em>linestyle=':'</em>, <em>color='blue'</em>, <em>cmap='plasma'</em><span class="sig-paren">)</span></dt>
<dd><p>Plot a XANES spectrum on an axes. Applies some color formatting if
<cite>edge</cite> is a valid XANES Edge object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spectrum</strong> (<em>-</em>) &#8211; </li>
<li><strong>energies</strong> (<em>-</em>) &#8211; </li>
<li><strong>norm</strong> (<em>-</em>) &#8211; range. This will be used to annotate the plot if it is give.</li>
<li><strong>show_fit</strong> (<em>-</em>) &#8211; </li>
<li><strong>ax</strong> (<em>-</em>) &#8211; will be generated.</li>
<li><strong>ax2</strong> (<em>-</em>) &#8211; the data are complex.</li>
<li><strong>linestyle</strong> (<em>-</em>) &#8211; </li>
<li><strong>cmap</strong> (<em>-</em>) &#8211; </li>
<li><strong>color</strong> (<em>-</em>) &#8211; or &#8220;y&#8221; will decide based on the numerical value, <cite>norm</cite> and
<cite>cmap</cite> arguments. Anything else will be passed as a color spec
to the matplotlib commands.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.remove_extra_spines">
<code class="descclassname">xanespy.plots.</code><code class="descname">remove_extra_spines</code><span class="sig-paren">(</span><em>ax</em><span class="sig-paren">)</span></dt>
<dd><p>Removes the right and top borders from the axes.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.set_axes_color">
<code class="descclassname">xanespy.plots.</code><code class="descname">set_axes_color</code><span class="sig-paren">(</span><em>ax</em>, <em>color</em><span class="sig-paren">)</span></dt>
<dd><p>Set the axes, tick marks, etc of <cite>ax</cite> to mpl color <cite>color</cite>. Also,
&#8220;doegreen&#8221; has special significance as the color associated with the
US department of energy.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.plots.set_outside_ticks">
<code class="descclassname">xanespy.plots.</code><code class="descname">set_outside_ticks</code><span class="sig-paren">(</span><em>ax</em><span class="sig-paren">)</span></dt>
<dd><p>Convert all the axes so that the ticks are on the outside and don&#8217;t
obscure data.</p>
</dd></dl>

</div>
<div class="section" id="module-xanespy.qt_frame_view">
<span id="xanespy-qt-frame-view-module"></span><h2>xanespy.qt_frame_view module</h2>
<dl class="class">
<dt id="xanespy.qt_frame_view.FrameAnimation">
<em class="property">class </em><code class="descclassname">xanespy.qt_frame_view.</code><code class="descname">FrameAnimation</code><span class="sig-paren">(</span><em>fig</em>, <em>artists</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">matplotlib.animation.ArtistAnimation</span></code></p>
<p>Performs the animation for scrolling through frames arbitarily.</p>
<dl class="method">
<dt id="xanespy.qt_frame_view.FrameAnimation.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.qt_frame_view.FrameChangeSource">
<em class="property">class </em><code class="descclassname">xanespy.qt_frame_view.</code><code class="descname">FrameChangeSource</code><span class="sig-paren">(</span><em>view</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtCore.QObject</span></code></p>
<dl class="method">
<dt id="xanespy.qt_frame_view.FrameChangeSource.add_callback">
<code class="descname">add_callback</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.FrameChangeSource.callbacks">
<code class="descname">callbacks</code><em class="property"> = []</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.FrameChangeSource.remove_callback">
<code class="descname">remove_callback</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.FrameChangeSource.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.FrameChangeSource.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.qt_frame_view.QtFrameView">
<em class="property">class </em><code class="descclassname">xanespy.qt_frame_view.</code><code class="descname">QtFrameView</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtCore.QObject</span></code></p>
<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.add_hdf_tree_item">
<code class="descname">add_hdf_tree_item</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.clear_axes">
<code class="descname">clear_axes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.connect_signals">
<code class="descname">connect_signals</code><span class="sig-paren">(</span><em>presenter</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.create_canvas">
<code class="descname">create_canvas</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.create_status_bar">
<code class="descname">create_status_bar</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.disable_frame_controls">
<code class="descname">disable_frame_controls</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.disable_plotting_controls">
<code class="descname">disable_plotting_controls</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.draw_frames">
<code class="descname">draw_frames</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.draw_histogram">
<code class="descname">draw_histogram</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.draw_spectrum">
<code class="descname">draw_spectrum</code><span class="sig-paren">(</span><em>spectrum</em>, <em>energies</em>, <em>norm</em>, <em>cmap</em>, <em>edge_range</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.edge_ax">
<code class="descname">edge_ax</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.expand_hdf_tree">
<code class="descname">expand_hdf_tree</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.fig">
<code class="descname">fig</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.frame_changed">
<code class="descname">frame_changed</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.frame_controls">
<code class="descname">frame_controls</code></dt>
<dd><p>Gives a list of all the UI buttons that are associated with
changing the currently active frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.hist_ax">
<code class="descname">hist_ax</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.hist_cb">
<code class="descname">hist_cb</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.plotting_controls">
<code class="descname">plotting_controls</code></dt>
<dd><p>Gives a list of all the UI elements that are associated with
changing how the frameset is plotted.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.select_active_hdf_item">
<code class="descname">select_active_hdf_item</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_cmap">
<code class="descname">set_cmap</code><span class="sig-paren">(</span><em>cmap</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_cmap_list">
<code class="descname">set_cmap_list</code><span class="sig-paren">(</span><em>cmap_list</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_drawing_status">
<code class="descname">set_drawing_status</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_slider_max">
<code class="descname">set_slider_max</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_status_cursor">
<code class="descname">set_status_cursor</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_status_energy">
<code class="descname">set_status_energy</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_status_index">
<code class="descname">set_status_index</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_status_pixel">
<code class="descname">set_status_pixel</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_status_shape">
<code class="descname">set_status_shape</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_status_unit">
<code class="descname">set_status_unit</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_status_value">
<code class="descname">set_status_value</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_timestep">
<code class="descname">set_timestep</code><span class="sig-paren">(</span><em>idx</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_timestep_list">
<code class="descname">set_timestep_list</code><span class="sig-paren">(</span><em>timestep_list</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_ui_enabled">
<code class="descname">set_ui_enabled</code><span class="sig-paren">(</span><em>enable=True</em><span class="sig-paren">)</span></dt>
<dd><p>Turn on (default) or off the main interactive elements in the
frame window. Useful for indicating blocking operations.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmax">
<code class="descname">set_vmax</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmax_decimals">
<code class="descname">set_vmax_decimals</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmax_minimum">
<code class="descname">set_vmax_minimum</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmax_step">
<code class="descname">set_vmax_step</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmin">
<code class="descname">set_vmin</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmin_decimals">
<code class="descname">set_vmin_decimals</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmin_maximum">
<code class="descname">set_vmin_maximum</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_vmin_step">
<code class="descname">set_vmin_step</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.set_window_title">
<code class="descname">set_window_title</code><span class="sig-paren">(</span><em>title</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.show">
<code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.show_status_message">
<code class="descname">show_status_message</code><span class="sig-paren">(</span><em>message</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.spectrum_ax">
<code class="descname">spectrum_ax</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.ui">
<code class="descname">ui</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frame_view.QtFrameView.use_busy_cursor">
<code class="descname">use_busy_cursor</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frame_view.QtFrameView.window">
<code class="descname">window</code><em class="property"> = None</em></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy.qt_frameset_presenter">
<span id="xanespy-qt-frameset-presenter-module"></span><h2>xanespy.qt_frameset_presenter module</h2>
<dl class="class">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter">
<em class="property">class </em><code class="descclassname">xanespy.qt_frameset_presenter.</code><code class="descname">QtFramesetPresenter</code><span class="sig-paren">(</span><em>frameset</em>, <em>frame_view</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtCore.QObject</span></code></p>
<p>Presenter for showing XanesFrameset frames and maps via Qt.</p>
<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.app_ready">
<code class="descname">app_ready</code></dt>
<dd><p><em>pyqtSignal</em> &#8211; Emitted when the application has been created and is ready for drawing.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.busy_status_changed">
<code class="descname">busy_status_changed</code></dt>
<dd><p><em>pyqtSignal</em> &#8211; Emitted when processing has started or ended.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_data_changed">
<code class="descname">map_data_changed</code></dt>
<dd><p><em>pyqtSignal</em> &#8211; Emitted when the map data is different and should be re-plotted.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_data_cleared">
<code class="descname">map_data_cleared</code></dt>
<dd><p><em>pyqtSignal</em> &#8211; Emitted when no map data is available and plots can be cleared.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.active_frame">
<code class="descname">active_frame</code><em class="property"> = 0</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.active_frames">
<code class="descname">active_frames</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.active_map">
<code class="descname">active_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Returns the active map array if possible. If it doesn&#8217;t exist,
return None.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.active_representation">
<code class="descname">active_representation</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.active_timestep">
<code class="descname">active_timestep</code><em class="property"> = 0</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.add_frame_view">
<code class="descname">add_frame_view</code><span class="sig-paren">(</span><em>view</em>, <em>threaded=True</em><span class="sig-paren">)</span></dt>
<dd><p>Attach a view to this presenter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>view</strong> (<em>QObject</em>) &#8211; The view will be connected to signals that describe changes in
frame data.</li>
<li><strong>threaded</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If true, this view will be added to its own thread before
signals get connected</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.add_map_view">
<code class="descname">add_map_view</code><span class="sig-paren">(</span><em>view</em>, <em>threaded=True</em><span class="sig-paren">)</span></dt>
<dd><p>Attach a view to this presenter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>view</strong> (<em>QObject</em>) &#8211; The view will be connected to signals that describe changes in
map data.</li>
<li><strong>threaded</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If true, this view will be added to its own thread before
signals get connected, giving a snapier UI. Disabling makes
testing more straightforward.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.animate_frames">
<code class="descname">animate_frames</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">app_ready</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.build_hdf_tree">
<code class="descname">build_hdf_tree</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Build the items and insert them into the view&#8217;s HDF tree based on
the structure of the frameset&#8217;s HDF file.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">busy_status_changed</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.change_cmap">
<code class="descname">change_cmap</code><span class="sig-paren">(</span><em>new_cmap</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.change_hdf_group">
<code class="descname">change_hdf_group</code><span class="sig-paren">(</span><em>new_item</em>, <em>old_item</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.change_map_cmap">
<code class="descname">change_map_cmap</code><span class="sig-paren">(</span><em>new_cmap</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.cmap_list_changed">
<code class="descname">cmap_list_changed</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.connect_signals">
<code class="descname">connect_signals</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.create_app">
<code class="descname">create_app</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.draw_frame_histogram">
<code class="descname">draw_frame_histogram</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.draw_frame_spectra">
<code class="descname">draw_frame_spectra</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.first_frame">
<code class="descname">first_frame</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.frame_cmap">
<code class="descname">frame_cmap</code><em class="property"> = 'copper'</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.frame_norm">
<code class="descname">frame_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.frame_pixel">
<code class="descname">frame_pixel</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.hover_frame_pixel">
<code class="descname">hover_frame_pixel</code><span class="sig-paren">(</span><em>xy</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.last_frame">
<code class="descname">last_frame</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.launch">
<code class="descname">launch</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_cmap">
<code class="descname">map_cmap</code><em class="property"> = 'plasma'</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_cursor_changed">
<code class="descname">map_cursor_changed</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">map_data_changed</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">map_data_cleared</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_limits_changed">
<code class="descname">map_limits_changed</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_norm">
<code class="descname">map_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_pixel_changed">
<code class="descname">map_pixel_changed</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.map_spectrum_changed">
<code class="descname">map_spectrum_changed</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.mean_spectrum_changed">
<code class="descname">mean_spectrum_changed</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.move_map_pixel">
<code class="descname">move_map_pixel</code><span class="sig-paren">(</span><em>vert</em>, <em>horiz</em><span class="sig-paren">)</span></dt>
<dd><p>Move the active pixel by the given amount in each direction.</p>
<p>If the current pixel is not active, this is a no-op.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.move_slider">
<code class="descname">move_slider</code><span class="sig-paren">(</span><em>new_value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.next_frame">
<code class="descname">next_frame</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.num_frames">
<code class="descname">num_frames</code><em class="property"> = 0</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.play_frames">
<code class="descname">play_frames</code><span class="sig-paren">(</span><em>start</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.prepare_ui">
<code class="descname">prepare_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.previous_frame">
<code class="descname">previous_frame</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.process_events">
<code class="descname">process_events</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.refresh_frames">
<code class="descname">refresh_frames</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.reset_frame_range">
<code class="descname">reset_frame_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Reset the frame plotting vmin and vmax based on the currently
selected data. VMin will be the 1nd percentile and VMax will
be the 99th percentile. The results can be accessed by calling
the <cite>frame_norm()</cite> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>(vmin, vmax)</strong> (<em>(float, float)</em>) &#8211; A 2-tuple with the new min and max range.</li>
<li><em>None</em> &#8211; If current representation is not a valid map, None will be
returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.reset_map_range">
<code class="descname">reset_map_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Reset the map plotting vmin and vmax based on the currently
selected data. VMin will be the 1st percentile and VMax will
be the 99th percentile. This method also caches the values so
they can be retrieved via the <cite>map_norm()</cite> method. If the
current representation is not valid map data, then the cached
vmin and vmax will be returned with no other changes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>(vmin, vmax)</strong> &#8211; A 2-tuple with the current min and max range.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(float, float)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_frame_vmax">
<code class="descname">set_frame_vmax</code><span class="sig-paren">(</span><em>new_value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_frame_vmin">
<code class="descname">set_frame_vmin</code><span class="sig-paren">(</span><em>new_value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_map_cursor">
<code class="descname">set_map_cursor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_map_pixel">
<code class="descname">set_map_pixel</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_map_vmax">
<code class="descname">set_map_vmax</code><span class="sig-paren">(</span><em>new_value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_map_vmin">
<code class="descname">set_map_vmin</code><span class="sig-paren">(</span><em>new_value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_play_speed">
<code class="descname">set_play_speed</code><span class="sig-paren">(</span><em>new_speed</em><span class="sig-paren">)</span></dt>
<dd><p>Change how fast the play timer ticks. Input speeds should be in the
range of 0, 30 with 30 being the fastest. This is converted to timer
intervals between 1ms and 1000ms on a exponential scale.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.set_timestep">
<code class="descname">set_timestep</code><span class="sig-paren">(</span><em>new_timestep</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.timer">
<code class="descname">timer</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.toggle_edge_mask">
<code class="descname">toggle_edge_mask</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_frame_range_limits">
<code class="descname">update_frame_range_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Check that the (min, max, step) of the frame spinboxes are
reasonable. This should be called when the spinbox values change.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_map_limits">
<code class="descname">update_map_limits</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_maps">
<code class="descname">update_maps</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Send the current mapping data to the <cite>map_data_changed</cite> signal.</p>
<p>This method should be called after anything changes the visual
representation of the map. Examples:</p>
<ul class="simple">
<li>Changing the active representation</li>
<li>Changing the colormap</li>
<li>Changing the map normalization limits</li>
<li>Changing whether the XAS edge mask is applied</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_spectra">
<code class="descname">update_spectra</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get the most recent data for mean and single-pixel spectra and send
them out to the signals <cite>mean_spectrum_changed</cite> and
<cite>pixel_sepctrum_changed</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_status_frame">
<code class="descname">update_status_frame</code><span class="sig-paren">(</span><em>new_frame</em><span class="sig-paren">)</span></dt>
<dd><p>Create a string (and send it to the UI) that indicates the energy
of the requested frame.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_status_shape">
<code class="descname">update_status_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_status_unit">
<code class="descname">update_status_unit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.update_status_value">
<code class="descname">update_status_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_frameset_presenter.QtFramesetPresenter.use_edge_mask">
<code class="descname">use_edge_mask</code><em class="property"> = False</em></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy.qt_map_view">
<span id="xanespy-qt-map-view-module"></span><h2>xanespy.qt_map_view module</h2>
<dl class="class">
<dt id="xanespy.qt_map_view.QtMapView">
<em class="property">class </em><code class="descclassname">xanespy.qt_map_view.</code><code class="descname">QtMapView</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">PyQt5.QtCore.QObject</span></code></p>
<p>A Qt view for a frameset map. It should be controlled by a
presenter.</p>
<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.cmap_changed">
<code class="descname">cmap_changed</code></dt>
<dd><p><em>signal</em> &#8211; Fires when the user changes the colormap via the UI</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.limits_applied">
<code class="descname">limits_applied</code></dt>
<dd><p><em>signal</em> &#8211; Fires when the user requests that data be redrawn with new limits.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.limits_reset">
<code class="descname">limits_reset</code></dt>
<dd><p><em>signal</em> &#8211; Fires when the user asks that the norm limits be reset to the data.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">cmap_changed</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.connect_presenter">
<code class="descname">connect_presenter</code><span class="sig-paren">(</span><em>presenter</em><span class="sig-paren">)</span></dt>
<dd><p>Connect to signals for changed presenter state.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.create_canvas">
<code class="descname">create_canvas</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.crosshairs">
<code class="descname">crosshairs</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.edge_mask_toggled">
<code class="descname">edge_mask_toggled</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.fig">
<code class="descname">fig</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.hide">
<code class="descname">hide</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.keyboard_nav">
<code class="descname">keyboard_nav</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.latest_cmap">
<code class="descname">latest_cmap</code><em class="property"> = 'plasma'</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">limits_applied</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">limits_reset</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.map_clicked">
<code class="descname">map_clicked</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.map_hovered">
<code class="descname">map_hovered</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.map_moved">
<code class="descname">map_moved</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.map_vmax_changed">
<code class="descname">map_vmax_changed</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.map_vmin_changed">
<code class="descname">map_vmin_changed</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.mouse_clicked_canvas">
<code class="descname">mouse_clicked_canvas</code><span class="sig-paren">(</span><em>mouse_event</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.mouse_in_canvas">
<code class="descname">mouse_in_canvas</code><span class="sig-paren">(</span><em>mouse_event</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.plot_histogram_data">
<code class="descname">plot_histogram_data</code><span class="sig-paren">(</span><em>map_data</em>, <em>norm</em>, <em>cmap</em>, <em>extent</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.plot_map_data">
<code class="descname">plot_map_data</code><span class="sig-paren">(</span><em>map_data</em>, <em>norm</em>, <em>cmap</em>, <em>extent</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.plot_spectrum">
<code class="descname">plot_spectrum</code><span class="sig-paren">(</span><em>spectrum</em>, <em>norm</em>, <em>cmap</em>, <em>edge_range</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.redraw_canvas">
<code class="descname">redraw_canvas</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.redraw_crosshairs">
<code class="descname">redraw_crosshairs</code><span class="sig-paren">(</span><em>xy</em><span class="sig-paren">)</span></dt>
<dd><p>Draw a set of crosshairs on the map at location given by <cite>xy</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.set_cmap_list">
<code class="descname">set_cmap_list</code><span class="sig-paren">(</span><em>new_list</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.set_map_limits">
<code class="descname">set_map_limits</code><span class="sig-paren">(</span><em>vmin</em>, <em>vmax</em>, <em>step</em>, <em>decimals</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.setup_ui">
<code class="descname">setup_ui</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.show">
<code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.ui">
<code class="descname">ui</code><em class="property"> = None</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.update_crosshair_labels">
<code class="descname">update_crosshair_labels</code><span class="sig-paren">(</span><em>xy</em>, <em>pixel</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.qt_map_view.QtMapView.update_cursor_labels">
<code class="descname">update_cursor_labels</code><span class="sig-paren">(</span><em>xy</em>, <em>pixel</em>, <em>value</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.qt_map_view.QtMapView.window">
<code class="descname">window</code><em class="property"> = None</em></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy.txmstore">
<span id="xanespy-txmstore-module"></span><h2>xanespy.txmstore module</h2>
<p>Tools for accessing TXM data stored in an HDF5 file.</p>
<dl class="class">
<dt id="xanespy.txmstore.TXMStore">
<em class="property">class </em><code class="descclassname">xanespy.txmstore.</code><code class="descname">TXMStore</code><span class="sig-paren">(</span><em>hdf_filename: str</em>, <em>parent_name: str</em>, <em>data_name=None</em>, <em>mode='r'</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Wrapper around HDF5 file that stores TXM data. It has a series of
properties that return the corresponding HDF5 dataset object; the
TXMStore().attribute.value pattern can be used to get pure numpy
arrays. These objects should be used as a context manager to ensure
that the file is closed, especially if using a writing mode:</p>
<blockquote>
<div><dl class="docutils">
<dt>with TXMStore() as store:</dt>
<dd># Do stuff with store here</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hdf_filename</strong> (<em>str</em>) &#8211; Path to the HDF file to be used.</li>
<li><strong>parent_name</strong> (<em>str</em>) &#8211; Name of the top-level HDF5 group.</li>
<li><strong>data_name</strong> (<em>str</em>) &#8211; Name of the second level HDF5 group, used for specific data
iterations (eg. imported, aligned)</li>
<li><strong>mode</strong> (<em>str</em>) &#8211; Eg. &#8216;r&#8217; for read-only, &#8216;r+&#8217; for read-write. Passed directly to
h5py.File constructor.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.VERSION">
<code class="descname">VERSION</code><em class="property"> = 1</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.absorbances">
<code class="descname">absorbances</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.cluster_map">
<code class="descname">cluster_map</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.data_group">
<code class="descname">data_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Retrieve the currently active second-level HDF5 group object for
this file and groupname. Ex. &#8220;imported&#8221; or &#8220;aligned_frames&#8221;.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.data_name">
<code class="descname">data_name</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.data_tree">
<code class="descname">data_tree</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Create a tree of the possible groups this store could access. The
first level is samples, then data_groups (ie. same sample but
different analysis status), then representations. Maps are not
included in this tree.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.energies">
<code class="descname">energies</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.filenames">
<code class="descname">filenames</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.fit_parameters">
<code class="descname">fit_parameters</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.fork_data_group">
<code class="descname">fork_data_group</code><span class="sig-paren">(</span><em>new_name</em><span class="sig-paren">)</span></dt>
<dd><p>Turn on different active data group for this store. This method
deletes the existing group and copies symlinks from the
current one.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.get_dataset">
<code class="descname">get_dataset</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>Attempt to open the requested dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>data</strong> &#8211; An open HDF5 dataset</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">hyp5.Dataset</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">exceptions.GroupKeyError</span></code> &#8211; If the dataset does not exist in the file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.get_frames">
<code class="descname">get_frames</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>Get a set of frames, specified by the value of <cite>name</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.get_map">
<code class="descname">get_map</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>Get a map of the frames, specified by the value of <cite>name</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.has_dataset">
<code class="descname">has_dataset</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span></dt>
<dd><p>Return a boolean indicated whether this dataset exists in the HDF
file.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.intensities">
<code class="descname">intensities</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.latest_data_name">
<code class="descname">latest_data_name</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.original_positions">
<code class="descname">original_positions</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.parent_group">
<code class="descname">parent_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Retrieve the top-level HDF5 group object for this file and
groupname.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.particle_labels">
<code class="descname">particle_labels</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.pixel_sizes">
<code class="descname">pixel_sizes</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.pixel_unit">
<code class="descname">pixel_unit</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.references">
<code class="descname">references</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.relative_positions">
<code class="descname">relative_positions</code></dt>
<dd><p>(x, y, z) position values for each frame.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.replace_dataset">
<code class="descname">replace_dataset</code><span class="sig-paren">(</span><em>name</em>, <em>data</em>, <em>context=None</em>, <em>attrs={}</em>, <em>compression=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Wrapper for h5py.create_dataset that removes the existing dataset
if it exists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; HDF5 groupname name to give this dataset.</li>
<li><strong>data</strong> (<em>np.ndarray</em>) &#8211; Numpy array of data to be saved.</li>
<li><strong>context</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Specifies what kind of data is stored. Eg. &#8220;frameset&#8221;,
&#8220;metadata&#8221;, &#8220;map&#8221;.</li>
<li><strong>attrs</strong> (<em>dict</em><em>, </em><em>optional</em>) &#8211; Dictionary containing HDF5 metadata attributes to be set on
the resulting dataset.</li>
<li><strong>*args</strong> &#8211; Arguments to pass to h5py&#8217;s <code class="docutils literal"><span class="pre">create_dataset</span></code> method.</li>
<li><strong>**kwargs</strong> &#8211; Keyword arguments to pass to h5py&#8217;s <code class="docutils literal"><span class="pre">create_dataset</span></code> method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.txmstore.TXMStore.set_frames">
<code class="descname">set_frames</code><span class="sig-paren">(</span><em>name</em>, <em>val</em><span class="sig-paren">)</span></dt>
<dd><p>Set data for a set of frames, specificied by the value of <cite>name</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.signal_map">
<code class="descname">signal_map</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.signal_method">
<code class="descname">signal_method</code></dt>
<dd><p>String describing how the previously extracted signals were
calculated.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.signal_weights">
<code class="descname">signal_weights</code></dt>
<dd><p>Get the pixel weights of the previously extracted signals using any
one of a variety of decomposition methods, saved as
<cite>signal_method</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.signals">
<code class="descname">signals</code></dt>
<dd><p>Get the previously extracted signals using any one of a variety of
decomposition methods, saved as <cite>signal_method</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.timestamps">
<code class="descname">timestamps</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.timestep_names">
<code class="descname">timestep_names</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.txmstore.TXMStore.whiteline_map">
<code class="descname">whiteline_map</code></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy.utilities">
<span id="xanespy-utilities-module"></span><h2>xanespy.utilities module</h2>
<p>A collection of classes and functions that arent&#8217; specific to any
one type of measurement. Also, it defines some namedtuples for
describing coordinates.</p>
<dl class="attribute">
<dt id="xanespy.utilities.Extent">
<code class="descclassname">xanespy.utilities.</code><code class="descname">Extent</code></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">extent</span></code></p>
</dd></dl>

<dl class="class">
<dt id="xanespy.utilities.Pixel">
<em class="property">class </em><code class="descclassname">xanespy.utilities.</code><code class="descname">Pixel</code><span class="sig-paren">(</span><em>vertical</em>, <em>horizontal</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<dl class="attribute">
<dt id="xanespy.utilities.Pixel.horizontal">
<code class="descname">horizontal</code></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.utilities.Pixel.vertical">
<code class="descname">vertical</code></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="xanespy.utilities.broadcast_reverse">
<code class="descclassname">xanespy.utilities.</code><code class="descname">broadcast_reverse</code><span class="sig-paren">(</span><em>array</em>, <em>shape</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Take the array and extends it as much as possible to match
<cite>shape</cite>. Similar to numpy&#8217;s broadcast_to function, but starts with
the most significant axis. For example, if <cite>array</cite> has shape (7,
29), it can be broadcast to (7, 29, 1024, 1024).</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.utilities.foreach">
<code class="descclassname">xanespy.utilities.</code><code class="descname">foreach</code><span class="sig-paren">(</span><em>f</em>, <em>l</em>, <em>threads=6</em>, <em>return_=False</em><span class="sig-paren">)</span></dt>
<dd><p>Apply f to each element of l, in parallel</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.utilities.get_component">
<code class="descclassname">xanespy.utilities.</code><code class="descname">get_component</code><span class="sig-paren">(</span><em>data</em>, <em>name</em><span class="sig-paren">)</span></dt>
<dd><p>If complex, turn to given component, otherwise return original data.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.utilities.is_kernel">
<code class="descclassname">xanespy.utilities.</code><code class="descname">is_kernel</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Detect whether or not we&#8217;re running inside an IPython kernel. NB:
This does not distinguish between eg IPython notebook and IPython
QtConsole.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.utilities.parallel_map">
<code class="descclassname">xanespy.utilities.</code><code class="descname">parallel_map</code><span class="sig-paren">(</span><em>f</em>, <em>l</em>, <em>threads=6</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="function">
<dt id="xanespy.utilities.pixel_to_xy">
<code class="descclassname">xanespy.utilities.</code><code class="descname">pixel_to_xy</code><span class="sig-paren">(</span><em>pixel</em>, <em>extent</em>, <em>shape</em><span class="sig-paren">)</span></dt>
<dd><p>Take an xy location on an image and convert it to a pixel location
suitable for numpy indexing.</p>
</dd></dl>

<dl class="class">
<dt id="xanespy.utilities.position">
<em class="property">class </em><code class="descclassname">xanespy.utilities.</code><code class="descname">position</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<dl class="attribute">
<dt id="xanespy.utilities.position.x">
<code class="descname">x</code></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.utilities.position.y">
<code class="descname">y</code></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.utilities.position.z">
<code class="descname">z</code></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="xanespy.utilities.prog">
<code class="descclassname">xanespy.utilities.</code><code class="descname">prog</code><span class="sig-paren">(</span><em>leave=False</em>, <em>dynamic_ncols=True</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>A progress bar for displaying how many iterations have been
completed. This is mostly just a wrapper around the tqdm
library. args and kwargs are passed directly to either
tqdm.tqdm or tqdm.tqdm_notebook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>leave</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; Whether to leave the progress bar in the stream after it&#8217;s
completed.</li>
<li><strong>dynamic_ncols</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; Whether to adapt dynamically to the width of the environment.</li>
<li><strong>args</strong> &#8211; Positional arguments passed directly to <code class="docutils literal"><span class="pre">tqdm</span></code> or <code class="docutils literal"><span class="pre">tqdm_notebook</span></code>.</li>
<li><strong>kwargs</strong> &#8211; Keyword arguments passed directly to <code class="docutils literal"><span class="pre">tqdm</span></code> or <code class="docutils literal"><span class="pre">tqdm_notebook</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="xanespy.utilities.shape">
<em class="property">class </em><code class="descclassname">xanespy.utilities.</code><code class="descname">shape</code><span class="sig-paren">(</span><em>rows</em>, <em>columns</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<dl class="attribute">
<dt id="xanespy.utilities.shape.columns">
<code class="descname">columns</code></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.utilities.shape.rows">
<code class="descname">rows</code></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="xanespy.utilities.xy_to_pixel">
<code class="descclassname">xanespy.utilities.</code><code class="descname">xy_to_pixel</code><span class="sig-paren">(</span><em>xy</em>, <em>extent</em>, <em>shape</em><span class="sig-paren">)</span></dt>
<dd><p>Take an xy location on an image and convert it to a pixel location
suitable for numpy indexing.</p>
</dd></dl>

<dl class="class">
<dt id="xanespy.utilities.xycoord">
<em class="property">class </em><code class="descclassname">xanespy.utilities.</code><code class="descname">xycoord</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<dl class="attribute">
<dt id="xanespy.utilities.xycoord.x">
<code class="descname">x</code></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.utilities.xycoord.y">
<code class="descname">y</code></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy.xanes_frameset">
<span id="xanespy-xanes-frameset-module"></span><h2>xanespy.xanes_frameset module</h2>
<p>Class definitions for working with a whole stack of X-ray
microscopy frames. Each frame is a micrograph at a different energy. A
frameset then is a three-dimenional dataset with of dimenions (energy,
row, column).</p>
<dl class="class">
<dt id="xanespy.xanes_frameset.PtychoFrameset">
<em class="property">class </em><code class="descclassname">xanespy.xanes_frameset.</code><code class="descname">PtychoFrameset</code><span class="sig-paren">(</span><em>filename</em>, <em>edge</em>, <em>groupname=None</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="#xanespy.xanes_frameset.XanesFrameset" title="xanespy.xanes_frameset.XanesFrameset"><code class="xref py py-class docutils literal"><span class="pre">xanespy.xanes_frameset.XanesFrameset</span></code></a></p>
<p>A set of images (&#8220;frames&#8221;) at different energies moving across an
absorption edge. The individual frames should be generated by
ptychographic reconstruction of scanning transmission X-ray
microscopy (STXM) to produce an array complex intensity
values. This class does <em>not</em> include any code responsible for the
collection and reconstruction of such data, only for the analysis
in the context of X-ray absorption near edge spectroscopy.</p>
<dl class="method">
<dt id="xanespy.xanes_frameset.PtychoFrameset.apply_internal_reference">
<code class="descname">apply_internal_reference</code><span class="sig-paren">(</span><em>plot_background=True</em>, <em>ax=None</em><span class="sig-paren">)</span></dt>
<dd><p>Use a portion of each frame for internal reference correction. The
result is the complex refraction for each pixel: the real
component describes the phase shift, and the imaginary
component is exponential decay, ie. absorbance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>plot_background</strong> (<em>If truthy</em><em>, </em><em>the values of I_0 are plotted as</em>) &#8211; a function of energy.</li>
<li><strong>ax</strong> (The axes to use for plotting if <cite>plot_background</cite> is) &#8211; truthy.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.PtychoFrameset.representations">
<code class="descname">representations</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Retrieve a list of valid representations for these data, such as
modulus or phase data for ptychography.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="xanespy.xanes_frameset.XanesFrameset">
<em class="property">class </em><code class="descclassname">xanespy.xanes_frameset.</code><code class="descname">XanesFrameset</code><span class="sig-paren">(</span><em>filename</em>, <em>edge</em>, <em>groupname=None</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A collection of TXM frames at different energies moving across an
absorption edge. Iterating over this object gives the individual
Frame() objects. The class assumes that the data have been
imported into an HDF file.</p>
<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.active_group">
<code class="descname">active_group</code><em class="property"> = ''</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.active_labels_groupname">
<code class="descname">active_labels_groupname</code></dt>
<dd><p>The group name for the latest frameset of detected particle labels.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.add_frame">
<code class="descname">add_frame</code><span class="sig-paren">(</span><em>frame</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.align_frames">
<code class="descname">align_frames</code><span class="sig-paren">(</span><em>reference_frame='mean'</em>, <em>blur=None</em>, <em>method: str = 'cross_correlation'</em>, <em>template=None</em>, <em>passes=1</em>, <em>commit=True</em>, <em>component='modulus'</em>, <em>plot_results=True</em><span class="sig-paren">)</span></dt>
<dd><p>Use cross correlation algorithm to line up the frames. All frames
will have their sample position set to (0, 0) since we don&#8217;t
know which one is the real position. This operation will
interpolate between pixels so introduces error. If multiple
passes are performed, the translations are saved and combined
at the end so this error is only introduced once. Using the
<cite>commit=False</cite> argument allows for multiple different types of
registration to be performed in sequence, since uncommitted
translations will be applied before the next round of
registration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong></strong><strong>(</strong><strong>int</strong><strong>, </strong><strong>str</strong><strong> or </strong><strong>None</strong><strong>)</strong><strong></strong> (<em>reference_frame</em>) &#8211; which all other frames should be aligned. If None, the frame
of highest intensity will be used. If &#8220;mean&#8221; (default) or
&#8220;median&#8221;, the average or median of all frames will be
used. If &#8220;max&#8221;, the frame with highest absorbance is
used. This attribute has no effect if template matching is
used.</li>
<li><strong>blur</strong> (<em>A type of filter to apply to each frame of the data</em>) &#8211; before attempting registration. Choices are &#8220;median&#8221; or None</li>
<li><strong>method</strong> (<em>Which technique to use to calculate the translation</em>) &#8211; <ul>
<li>&#8220;cross_correlation&#8221; (default)</li>
<li>&#8220;template_match&#8221;</li>
</ul>
<p>(If &#8220;template_match&#8221; is used, the <cite>template</cite> argument should
also be provided.)</p>
</li>
<li><strong>passes</strong> (<em>How many times this alignment should be done. Default: 1.</em>) &#8211; </li>
<li><strong>template</strong> (<em>Image data that should be matched if the</em>) &#8211; <cite>template_match</cite> method is used.</li>
<li><strong>commit</strong> (<em>If truthy</em><em> (</em><em>default</em><em>)</em><em></em><em>, </em><em>the final translation will be</em>) &#8211; applied to the data stored on disk by calling
<cite>self.apply_translations(crop=True)</cite> after all passes have
finished.</li>
<li><strong>component</strong> (<em>What component of the data to use: 'modulus'</em><em>,</em><em></em>) &#8211; &#8216;phase&#8217;, &#8216;imag&#8217; or &#8216;real&#8217;.</li>
<li><strong>plot_results</strong> (<em>If truthy</em><em> (</em><em>default</em><em>)</em><em></em><em>, </em><em>plot the root-mean-square of the</em>) &#8211; translation distance for each pass.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.apply_transformations">
<code class="descname">apply_transformations</code><span class="sig-paren">(</span><em>crop=True</em>, <em>commit=True</em><span class="sig-paren">)</span></dt>
<dd><p>Take any transformations staged with <cite>self.stage_transformations()</cite>
and apply them. If commit is truthy, the staged
transformations are reset.</p>
<p>Returns: Transformed array of the absorbances frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>crop</strong> (<em>-</em>) &#8211; </li>
<li><strong>so there are not edges. If falsy</strong><strong>, </strong><strong>the images will</strong> (<em>translated</em><em>,</em><em></em>) &#8211; </li>
<li><strong>wrapped.</strong> (<em>be</em>) &#8211; </li>
<li><strong>commit</strong> (<em>-</em>) &#8211; store for absorbances, intensities and references, and the
staged transformations will be cleared. Otherwise, only the
absorbance data will be transformed and returned.</li>
<li><strong>frames_name</strong> (<em>-</em>) &#8211; transformation too (eg. &#8216;absorbances&#8217;)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.background_group">
<code class="descname">background_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.background_normalizer">
<code class="descname">background_normalizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.calculate_maps">
<code class="descname">calculate_maps</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Generate a set of maps based on pixel-wise Xanes spectra: whiteline
position, particle labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>-fit_spectra</strong> (<em>If truthy</em><em>, </em><em>the whiteline will be found by</em>) &#8211; fitting curves, instead of the default of taking the direct
maximum.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.calculate_signals">
<code class="descname">calculate_signals</code><span class="sig-paren">(</span><em>n_components=2</em>, <em>method='nmf'</em>, <em>edge_mask=True</em><span class="sig-paren">)</span></dt>
<dd><p>Extract signals and assign each pixel to a group, then save the
resulting RGB cluster map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_components</strong> (<em>-</em>) &#8211; into which the data will be separated.</li>
<li><strong>method</strong> (<em>-</em>) &#8211; signals. Currently only &#8220;nmf&#8221; is supported.</li>
<li><strong>edge_mask</strong> (<em>-</em>) &#8211; the edge filter will be considered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.calculate_whitelines">
<code class="descname">calculate_whitelines</code><span class="sig-paren">(</span><em>edge_mask=False</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate and save a map of the whiteline position of each pixel by
calculating the energy of simple maximum absorbance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edge_mask</strong> (<em>-</em>) &#8211; be fit and the remaning pixels will be set to a default
value. This can help reduce computing time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.clear_caches">
<code class="descname">clear_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Clear cached function values so they will be recomputed with fresh
data</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.cmap">
<code class="descname">cmap</code><em class="property"> = 'plasma'</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.data_name">
<code class="descname">data_name</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.data_tree">
<code class="descname">data_tree</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Wrapper around the TXMStore.data_tree() method.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.drop_frame">
<code class="descname">drop_frame</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span></dt>
<dd><p>Delete frame with the given index (int) or energy (float). This
destructively removes the data from the HDF5 file, so use with
caution.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.edge_jump">
<code class="descname">edge_jump</code></dt>
<dd><p>Calculate a image showing the difference in
signal across the X-ray edge.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.edge_mask">
<code class="descname">edge_mask</code></dt>
<dd><p>Calculate a mask for what is likely active material at this
edge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sensitivity</strong> (<em>float</em>) &#8211; A multiplier for the otsu value to determine
the actual threshold.</li>
<li><strong>min_size</strong> (<em>int</em>) &#8211; Objects below this size (in pixels) will be removed. Passing
zero (default) will result in no effect.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.endtime">
<code class="descname">endtime</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Determine the latest timestamp amongst all of the frames.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.energies">
<code class="descname">energies</code></dt>
<dd><p>Return the array of beam energies for the given time index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>energies</strong> &#8211; A 1-dimensional array with the energy for each frame.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">np.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.extent">
<code class="descname">extent</code></dt>
<dd><p>Determine physical dimensions for axes values.</p>
<p>Returns: If idx was given, a single tuple of (left, right,
bottom, up), otherwise if idx is None it returns an array of
extents for each frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>-idx</strong> (<em>Index for a given frame. This allows for faster</em>) &#8211; calculation if only a single frame is required. By default,
returns the first frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.fit_spectra">
<code class="descname">fit_spectra</code><span class="sig-paren">(</span><em>edge_mask=True</em><span class="sig-paren">)</span></dt>
<dd><p>Fit a series of curves to the spectrum at each pixel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edge_mask</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If true, only pixels passing the edge_mask will be fit and
the remaning pixels will be set to a default value. This can
help reduce computing time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.fork_data_group">
<code class="descname">fork_data_group</code><span class="sig-paren">(</span><em>new_name</em>, <em>src=None</em><span class="sig-paren">)</span></dt>
<dd><p>Turn on different active data for this frameset&#8217;s store
object. Similar to <cite>switch_data_group</cite> except that this method
deletes the existing group and copies symlinks from the current one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_name</strong> (<em>-</em>) &#8211; </li>
<li><strong>src</strong> (<em>-</em>) &#8211; from. If None (default), the current data group will be
used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.frame_shape">
<code class="descname">frame_shape</code><span class="sig-paren">(</span><em>representation='absorbances'</em><span class="sig-paren">)</span></dt>
<dd><p>Return the shape of the individual energy frames.</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.frames">
<code class="descname">frames</code></dt>
<dd><p>Return the frames for the given time index.</p>
<p>If <cite>representation</cite> is really mapping data, then the source
frames will be returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timeidx</strong> (<em>int</em>) &#8211; Index for the first dimension of the combined data array.</li>
<li><strong>representation</strong> (<em>str</em>) &#8211; The group name for these data. Eg &#8220;absorbances&#8221;,
&#8220;whiteline_map&#8221;, &#8220;intensities&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frames</strong> &#8211; A 3-dimensional array with the form (energy, row, col).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.goodness_mask">
<code class="descname">goodness_mask</code><span class="sig-paren">(</span><em>sensitivity: float = 0.5</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate an image based on the goodness of fit. <cite>calculate_map</cite>
must have been called previously. Goodness filter is converted
to a binary map using (Otsu) threshold filtering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sensitivity</strong> (<em>-</em>) &#8211; the actual threshold.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.gtk_viewer">
<code class="descname">gtk_viewer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Launch a GTK gui to view the data in the frameset.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.has_representation">
<code class="descname">has_representation</code><span class="sig-paren">(</span><em>representation</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.hdf_file">
<code class="descname">hdf_file</code><span class="sig-paren">(</span><em>mode='r'</em><span class="sig-paren">)</span></dt>
<dd><p>Return an open h5py.File object for this (any maybe other) frameset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mode</strong> (<em>A mode string</em><em>, </em><em>see h5py documentation for options. To</em>) &#8211; </li>
<li><strong>file corruption</strong><strong>, </strong><strong>calling this method as a context</strong> (<em>avoid</em>) &#8211; </li>
<li><strong>is recommended</strong><strong>, </strong><strong>especially with a mode other than 'r'.</strong> (<em>manager</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.hdf_node">
<code class="descname">hdf_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>For use with HDFAttribute descriptor.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.hdf_path">
<code class="descname">hdf_path</code><span class="sig-paren">(</span><em>representation=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return the hdf path for the active group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>representation</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Name of third-level group to use. If omitted, the path to
the parent group will be given.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>path</strong> &#8211; The path to the current group in the HDF5 file. Returns an
empty string if the representation does not exists.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.image_normalizer">
<code class="descname">image_normalizer</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.is_background">
<code class="descname">is_background</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.label_particles">
<code class="descname">label_particles</code><span class="sig-paren">(</span><em>min_distance=20</em><span class="sig-paren">)</span></dt>
<dd><p>Use watershed segmentation to identify particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>min_distance</strong> (<em>-</em>) &#8211; grouping areas into particles. Lower numbers means more
particles, but might split large particles into two.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.map_data">
<code class="descname">map_data</code></dt>
<dd><p>Return map data for the given time index and representation.</p>
<p>If <cite>representation</cite> is really mapping data, then the result
will have more dimensions than expected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timeidx</strong> (<em>int</em>) &#8211; Index for the first dimension of the combined data array.</li>
<li><strong>representation</strong> (<em>str</em>) &#8211; The group name for these data. Eg &#8220;absorbances&#8221;,
&#8220;whiteline_map&#8221;, &#8220;intensities&#8221;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>map_data</strong> &#8211; A 2-dimensional array with the form (row, col).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.masked_map">
<code class="descname">masked_map</code><span class="sig-paren">(</span><em>goodness_filter=True</em><span class="sig-paren">)</span></dt>
<dd><p>Generate a map based on pixel-wise Xanes spectra and apply an
edge-jump filter mask. Default is to compute X-ray whiteline
position.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.mean_frame">
<code class="descname">mean_frame</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return the mean absorbance with the same shape as an individual
frame.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.movie_plotter">
<code class="descname">movie_plotter</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Creates an animation of all the frames in ascending energy, but
does not display it anywhere, that&#8217;s up to you.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>plot_fit=False</em>, <em>new_name='normalized'</em><span class="sig-paren">)</span></dt>
<dd><p>Correct for background material not absorbing at this edge. Uses
method described in DOI 10.1038/ncomms7883: fit line against
material that fails edge_jump_filter and use this line to
correct entire frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>plot_fit</strong> (<em>-</em>) &#8211; </li>
<li><strong>line.</strong> (<em>best-fit</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.num_energies">
<code class="descname">num_energies</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_frameset.XanesFrameset.num_timesteps">
<code class="descname">num_timesteps</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.particle">
<code class="descname">particle</code><span class="sig-paren">(</span><em>particle_idx=0</em><span class="sig-paren">)</span></dt>
<dd><p>Prepare a particle frameset for the given particle index.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.particle_area_spectrum">
<code class="descname">particle_area_spectrum</code><span class="sig-paren">(</span><em>loc=xycoord(x=20</em>, <em>y=20)</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate a spectrum based on the area of the particle closest to
the given location in the frame. This may be useful for assessing
magnification across multiple frames.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.particle_centroid_spectrum">
<code class="descname">particle_centroid_spectrum</code><span class="sig-paren">(</span><em>loc=xycoord(x=20</em>, <em>y=20)</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate a spectrum based on the image centroid of the particle
closest to the given location in the frame. This may be useful
for assessing systematic drift across multiple frames.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.particle_regions">
<code class="descname">particle_regions</code><span class="sig-paren">(</span><em>intensity_image=None</em>, <em>labels=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return a list of regions (1 for each particle) sorted by area.
(largest first). This requires that the <cite>label_particles</cite>
method be called first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>intensity_image</strong> (<em>-</em>) &#8211; <cite>regionprops</cite> function to determine what shows up in the
image for each particle.</li>
<li><strong>labels</strong> (<em>-</em>) &#8211; particles segmented. If None, the <cite>particle_labels</cite>
attribute of the TXM store will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.particle_series">
<code class="descname">particle_series</code><span class="sig-paren">(</span><em>map_name='whiteline_map'</em><span class="sig-paren">)</span></dt>
<dd><p>Generate an array of values from map_name averaged across each
particle.</p>
<p>Returns: A 2D array where the first dimension is particles and
the second is the first dimension of the map dataset (usually time).</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.pixel_unit">
<code class="descname">pixel_unit</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return the unit of measure for the size of a pixel.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_edge_jump">
<code class="descname">plot_edge_jump</code><span class="sig-paren">(</span><em>ax=None</em>, <em>alpha=1</em><span class="sig-paren">)</span></dt>
<dd><p>Plot the results of the edge jump filter.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_frame">
<code class="descname">plot_frame</code><span class="sig-paren">(</span><em>idx</em>, <em>ax=None</em>, <em>cmap='gray'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Plot the frame with given index as an image.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_goodness">
<code class="descname">plot_goodness</code><span class="sig-paren">(</span><em>plotter=None</em>, <em>ax=None</em>, <em>norm_range=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Use a default frameset plotter to draw a map of the goodness of fit
as determined by the Edge object.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_histogram">
<code class="descname">plot_histogram</code><span class="sig-paren">(</span><em>plotter=None</em>, <em>timeidx=None</em>, <em>ax=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>goodness_filter=False</em>, <em>active_pixel=None</em>, <em>bins='energies'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Use a default frameset plotter to draw a map of the chemical
data.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_map">
<code class="descname">plot_map</code><span class="sig-paren">(</span><em>ax=None</em>, <em>map_name='whiteline_map'</em>, <em>timeidx=0</em>, <em>vmin=None</em>, <em>vmax=None</em><span class="sig-paren">)</span></dt>
<dd><p>Prepare data and plot a map of whiteline positions.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_map_pixel_spectra">
<code class="descname">plot_map_pixel_spectra</code><span class="sig-paren">(</span><em>pixels</em>, <em>map_ax=None</em>, <em>spectra_ax=None</em>, <em>map_name='whiteline_map'</em>, <em>timeidx=0</em>, <em>step_size=0</em><span class="sig-paren">)</span></dt>
<dd><p>Plot the frameset&#8217;s map and highlight some pixels on it then plot
those pixel&#8217;s spectra on another set of axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pixels</strong> (<em>-</em>) &#8211; column) pixels to highlight.</li>
<li><strong>map_ax</strong> (<em>-</em>) &#8211; None, a new 2-wide subplot will be created for both map_ax
and spectra_ax.</li>
<li><strong>spectra_ax</strong> (<em>-</em>) &#8211; spectra. Will only be used if <cite>map_ax</cite> is not None.</li>
<li><strong>map_name</strong> (<em>-</em>) &#8211; passed to the TXM store object and retrieved from the hdf5
file. If falsy, no map will be plotted.</li>
<li><strong>timeidx</strong> (<em>-</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_mean_image">
<code class="descname">plot_mean_image</code><span class="sig-paren">(</span><em>ax=None</em>, <em>component='modulus'</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_signal_map">
<code class="descname">plot_signal_map</code><span class="sig-paren">(</span><em>ax=None</em>, <em>signals_idx=None</em><span class="sig-paren">)</span></dt>
<dd><p>Plot the map of signal strength for signals extracted from
self.calculate_signals().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ax</strong> (<em>-</em>) &#8211; axes object is created.</li>
<li><strong>signals_idx</strong> (<em>-</em>) &#8211; </li>
<li><strong>as a numpy array index. Special value None</strong><strong> (</strong><strong>default</strong><strong>)</strong><strong></strong> (<em>passed</em>) &#8211; </li>
<li><strong>first three signals will be plotted.</strong> (<em>means</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_signals">
<code class="descname">plot_signals</code><span class="sig-paren">(</span><em>cmap='viridis'</em><span class="sig-paren">)</span></dt>
<dd><p>Plot the signals from the previously extracted data. Requires that
self.store().signals and self.store().signal_weights be
set.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_xanes_edge">
<code class="descname">plot_xanes_edge</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Call self.plots.plot_xanes_spectrum() but zoomed in on the edge.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.plot_xanes_spectrum">
<code class="descname">plot_xanes_spectrum</code><span class="sig-paren">(</span><em>ax=None</em>, <em>pixel=None</em>, <em>norm_range=None</em>, <em>normalize=False</em>, <em>representation='modulus'</em>, <em>show_fit=False</em>, <em>edge_jump_filter=False</em>, <em>linestyle=':'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate and plot the xanes spectrum for this field-of-view.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>- matplotlib axes object on which to draw</strong> (<em>ax</em>) &#8211; </li>
<li><strong>- Coordinates of a specific pixel on the image to plot.</strong> (<em>pixel</em>) &#8211; </li>
<li><strong>- If truthy</strong><strong>, </strong><strong>will set the pre-edge at zero and the</strong> (<a class="reference internal" href="#xanespy.xanes_frameset.XanesFrameset.normalize" title="xanespy.xanes_frameset.XanesFrameset.normalize"><em>normalize</em></a>) &#8211; post-edge at 1.</li>
<li><strong>- If truthy</strong><strong>, </strong><strong>will use the edge object to fit the data</strong> (<em>show_fit</em>) &#8211; and plot the resulting fit line.</li>
<li><strong>- If truthy</strong><strong>, </strong><strong>will only include those values</strong> (<em>edge_jump_filter</em>) &#8211; that show a strong absorbtion jump across this edge.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.qt_viewer">
<code class="descname">qt_viewer</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.representations">
<code class="descname">representations</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Retrieve a list of valid representations for these data.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.save_movie">
<code class="descname">save_movie</code><span class="sig-paren">(</span><em>filename</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Save an animation of all the frames and XANES to the specified
filename.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.spectra">
<code class="descname">spectra</code><span class="sig-paren">(</span><em>edge_filter=False</em><span class="sig-paren">)</span></dt>
<dd><p>Return a two-dimensional array of spectra for all the pixels in
shape of (pixel, energy).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong></strong><strong>(</strong><strong>bool</strong><strong> or </strong><strong>str</strong><strong>)</strong><strong></strong> (<em>edge_jump_filter</em>) &#8211; truthy, only pixels that pass the edge jump filter are
used to calculate the spectrum. If &#8220;inverse&#8221; is given,
then the edge jump filter is logically not-ted and
calculated with a more conservative threshold.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.spectrum">
<code class="descname">spectrum</code><span class="sig-paren">(</span><em>pixel=None</em>, <em>edge_jump_filter=False</em>, <em>representation='absorbances'</em>, <em>index=0</em><span class="sig-paren">)</span></dt>
<dd><p>Collapse the frameset down to an energy spectrum.</p>
<p>Any dimensions (besides the energy dimension) that remain
after applying the arguments below, will be averaged to give
the final intensity at each energy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spectrum</strong> &#8211; A pandas Series with the spectrum.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">pd.Series</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pixel</strong> (<em>tuple</em><em>, </em><em>optional</em>) &#8211; A 2-tuple that causes the returned series to represent
the spectrum for only 1 pixel in the frameset. If None, a
larger part of the frame will be used, depending on the
other arguments.</li>
<li><strong>edge_jump_filter</strong> (<em>bool</em><em> or </em><em>str</em><em>, </em><em>optional</em>) &#8211; If truthy, only pixels that
pass the edge jump filter are used to calculate the
spectrum. If &#8220;inverse&#8221; is given, then the edge jump filter
is logically not-ted and calculated with a more
conservative threshold.</li>
<li><strong>representation</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; What kind of data to use for creating the spectrum. This
will be passed to TXMStore.get_map()</li>
<li><strong>index</strong> (<em>int</em><em>, </em><em>optional</em>) &#8211; Which step in the frameset to use. When used to index
store().absorbances, this should return a 3D array like
(energy, rows, columns).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.stage_transformations">
<code class="descname">stage_transformations</code><span class="sig-paren">(</span><em>translations=None</em>, <em>rotations=None</em>, <em>center=(0</em>, <em>0)</em>, <em>scales=None</em><span class="sig-paren">)</span></dt>
<dd><p>Allows for deferred transformation of the frame data.</p>
<p>Since each transformation introduces interpolation error, the
best results occur when the translations are saved up and then
applied all in one shot. Takes a combination of arrays of
translations (x, y), rotations and/or scales and saves them
for later application. This method should be used in
conjunction apply_transformations().</p>
<p>All three arguments should have shapes that are compatible
with the frame data, though this is not strictly enforced for
now. Rotation will necessarily have one less degree of freedom
than translation/scale values.</p>
<p>Example Shapes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="21%" />
<col width="19%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Frames</th>
<th class="head">Translations</th>
<th class="head">Rotations</th>
<th class="head">Scales</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>(10, 48, 1024, 1024)</td>
<td>(10, 48, 2)</td>
<td>(10, 48, 1)</td>
<td>(10, 48, 2)</td>
</tr>
<tr class="row-odd"><td>(10, 48, 1024, 1024, 1024)</td>
<td>(10, 48, 3)</td>
<td>(10, 48, 2)</td>
<td>(10, 48, 3)</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>translations</strong> (<em>np.ndarray</em>) &#8211; How much to move each axis (x, y[, z]).</li>
<li><strong>rotations</strong> (<em>np.ndarray</em>) &#8211; How much to rotate around the origin (0, 0) pixel.</li>
<li><strong>center</strong> (<em>2-tuple</em>) &#8211; Where to set the origin of rotation. Default is the first
pixel (0, 0).</li>
<li><strong>scales</strong> (<em>np.ndarray</em>) &#8211; How much to scale the image by in each dimension (x, y[,
z]).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.starttime">
<code class="descname">starttime</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Determine the earliest timestamp amongst all of the frames.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.store">
<code class="descname">store</code><span class="sig-paren">(</span><em>mode='r'</em><span class="sig-paren">)</span></dt>
<dd><p>Get a TXM Store object that saves and retrieves data from the HDF5
file. The mode argument is passed to h5py as is. This method
should be used as a context manager, especially if mode is
something writeable:</p>
<blockquote>
<div><dl class="docutils">
<dt>with self.store() as store:</dt>
<dd># Do stuff with the store</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="xanespy.xanes_frameset.XanesFrameset.subtract_surroundings">
<code class="descname">subtract_surroundings</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Use the edge mask to separate &#8220;surroundings&#8221; from &#8220;sample&#8221;, then
subtract the average surrounding absorbance from each
frame. This effective removes effects where the entire frame
is brighter from one energy to the next.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy.xanes_math">
<span id="xanespy-xanes-math-module"></span><h2>xanespy.xanes_math module</h2>
<p>Module containing all the computationally demanding functions. This
allows for easy optimization of parallelizable algorithms. Most
functions will operate on large arrays of data.</p>
<dl class="class">
<dt id="xanespy.xanes_math.KEdgeParams">
<em class="property">class </em><code class="descclassname">xanespy.xanes_math.</code><code class="descname">KEdgeParams</code><span class="sig-paren">(</span><em>scale</em>, <em>voffset</em>, <em>E0</em>, <em>sigw</em>, <em>pre_m</em>, <em>pre_b</em>, <em>ga</em>, <em>gb</em>, <em>gc</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.E0">
<code class="descname">E0</code></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.ga">
<code class="descname">ga</code></dt>
<dd><p>Alias for field number 6</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.gb">
<code class="descname">gb</code></dt>
<dd><p>Alias for field number 7</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.gc">
<code class="descname">gc</code></dt>
<dd><p>Alias for field number 8</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.pre_b">
<code class="descname">pre_b</code></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.pre_m">
<code class="descname">pre_m</code></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.scale">
<code class="descname">scale</code></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.sigw">
<code class="descname">sigw</code></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="attribute">
<dt id="xanespy.xanes_math.KEdgeParams.voffset">
<code class="descname">voffset</code></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.apply_internal_reference">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">apply_internal_reference</code><span class="sig-paren">(</span><em>intensities</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Apply a reference correction to complex data to convert intensities
into refractive index. <span class="math">\(I_0\)</span> is determined by separating the pixels
into background and foreground using Otsu&#8217;s method.</p>
<p>Arrays <cite>intensities</cite> and <cite>out</cite> must all have the same shape where
the last two dimensions are image rows and column.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.apply_references">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">apply_references</code><span class="sig-paren">(</span><em>intensities</em>, <em>references</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Apply a reference correction to convert intensity values to optical
depth.</p>
<p>The formula <span class="math">\(-ln\frac{intensities}{references}\)</span> is used to
calculate the new values. Arrays <code class="docutils literal"><span class="pre">intensities</span></code>, <code class="docutils literal"><span class="pre">references</span></code>
and <code class="docutils literal"><span class="pre">out</span></code> must all have the same shape where the last two
dimensions are image rows and columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>intensities</strong> (<em>np.ndarray</em>) &#8211; Sample input signal data.</li>
<li><strong>references</strong> (<em>np.ndarray</em>) &#8211; Background input signal data. Must be the same shape as
intensities.</li>
<li><strong>out</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) &#8211; Array to receive the results.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.direct_whitelines">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">direct_whitelines</code><span class="sig-paren">(</span><em>spectra</em>, <em>energies</em>, <em>edge</em><span class="sig-paren">)</span></dt>
<dd><p>Takes an array of X-ray absorbance spectra and calculates the
positions of maximum intensities over the near-edge region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>spectra</strong> (<em>np.array</em>) &#8211; 2D numpy array of absorbance spectra where the last dimension is
energy.</li>
<li><strong>energies</strong> (<em>np.array</em>) &#8211; Array of X-ray energies in electron-volts. Must be broadcastable
to the shape of spectra.</li>
<li><strong>edge</strong> &#8211; An XAS Edge object that describes the absorbance edge in
question.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> &#8211; Array with the whiteline position of each spectrum.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.extract_signals_nmf">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">extract_signals_nmf</code><span class="sig-paren">(</span><em>spectra</em>, <em>n_components</em>, <em>nmf_kwargs=None</em>, <em>mask=None</em><span class="sig-paren">)</span></dt>
<dd><p>Extract the signal components present in the given spectra using
non-negative matrix factorization. Input data can be negative, but
it will be shifted up, processed, then shifted down again.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>spectra</strong> (<em>-</em>) &#8211; </li>
<li><strong>n_components</strong> (<em>-</em>) &#8211; </li>
<li><strong>nmf_kwargs</strong> (<em>-</em>) &#8211; the constructor of the estimator.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2-tuple of arrays (components, weights)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.fit_kedge">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">fit_kedge</code><span class="sig-paren">(</span><em>spectra</em>, <em>energies</em>, <em>p0</em><span class="sig-paren">)</span></dt>
<dd><p>Use least squares to fit a set of curves to the data. Currently
this is a line for the baseline absorbance decreasing at higher
energies, plus a sigmoid for the edge and a gaussian for the
whiteline.</p>
<p>Returns an array with a similar shape to spectra but the last axis
is replaced with fitting parameters, describe by the named tupled
<cite>KParams</cite> defined in this module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spectra</strong> (<em>-</em>) &#8211; index is energy. This can be a multi-dimensional array, which
allows calculation of image frames, etc. The last axis should be
X-ray energy.</li>
<li><strong>energies</strong> (<em>-</em>) &#8211; </li>
<li><strong>p0</strong> (<em>-</em>) &#8211; described by kedge_params.</li>
<li><strong>out</strong> (<em>-</em>) &#8211; </li>
<li><strong>be created.</strong> (<em>will</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.guess_kedge">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">guess_kedge</code><span class="sig-paren">(</span><em>spectrum</em>, <em>energies</em>, <em>edge</em><span class="sig-paren">)</span></dt>
<dd><p>Guess initial starting parameters for a k-edge curve. This will
give a rough estimate, appropriate for giving to the fit_kedge
function as the starting parameters, p0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spectrum</strong> (<em>-</em>) &#8211; K-edge spectrum. Only 1-dimensional data are currently accepted.</li>
<li><strong>energies</strong> (<em>-</em>) &#8211; the points in <cite>spectrum</cite>. Must have the same shape as <cite>spectrum</cite>.</li>
<li><strong>edge</strong> (<em>-</em>) &#8211; actual edge energy itself.</li>
<li><strong>Returns</strong> (<em>A named tuple with the estimated parameters</em><em> (</em><em>see</em>) &#8211; .KEdgeParams for definition)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.iter_indices">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">iter_indices</code><span class="sig-paren">(</span><em>data</em>, <em>leftover_dims=1</em>, <em>desc=None</em><span class="sig-paren">)</span></dt>
<dd><p>Accept an array of frames, indices, etc. and generate slices for
each frame. Assumes the last two dimensions of <cite>data</cite> are rows and
columns. All other dimensions will be iterated over.</p>
<ul class="simple">
<li>leftover_dims : Integer describing which dimensions should not
be iterated over. Eg. if data is 3D array and leftover_dims == 1,
only first two dimenions will be iterated.</li>
<li>desc : String to put in the progress bar.</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.k_edge_jump">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">k_edge_jump</code><span class="sig-paren">(</span><em>frames: numpy.ndarray</em>, <em>energies: numpy.ndarray</em>, <em>edge</em><span class="sig-paren">)</span></dt>
<dd><p>Determine what the difference is between the post_edge and the
pre_edge.</p>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.k_edge_mask">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">k_edge_mask</code><span class="sig-paren">(</span><em>frames: numpy.ndarray</em>, <em>energies: numpy.ndarray</em>, <em>edge</em>, <em>sensitivity: float = 1</em>, <em>min_size=0</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate a mask for what is likely active material at this
edge. This is done by comparing the edge-jump to the standard
deviation. Foreground material will be identified when the
edge-jump accounts for most of the standard deviation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>-</em>) &#8211; </li>
<li><strong>energies</strong> (<em>-</em>) &#8211; <cite>frames</cite>. Must have the same shape along the first dimenion as
<cite>frames</cite>.</li>
<li><strong>edge</strong> (<em>-</em>) &#8211; elemental edge being studied.</li>
<li><strong>sensitivity</strong> (<em>-</em>) &#8211; the actual threshold.</li>
<li><strong>min_size</strong> (<em>-</em>) &#8211; removed. Passing zero (default) will result in no effect.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><em>- A boolean mask with the same shape as the last two dimensions of</em></li>
<li><cite>frames</cite> where True pixels are likely to be background material.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.l_edge_mask">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">l_edge_mask</code><span class="sig-paren">(</span><em>frames: numpy.ndarray</em>, <em>energies: numpy.ndarray</em>, <em>edge</em>, <em>sensitivity: float = 1</em>, <em>frame_dims=2</em>, <em>min_size=0</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate a mask for what is likely active material at this
edge. This is done by comparing each spectrum to the overall
spectrum using the dot product. A normalization is first applied
to mitigate differences in total intensity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>-</em>) &#8211; </li>
<li><strong>energies</strong> (<em>-</em>) &#8211; <cite>frames</cite>. Must have the same shape along the first dimenion as
<cite>frames</cite>.</li>
<li><strong>edge</strong> (<em>-</em>) &#8211; elemental edge being studied.</li>
<li><strong>sensitivity</strong> (<em>-</em>) &#8211; the actual threshold.</li>
<li><strong>frame_dims</strong> (<em>-</em>) &#8211; means each frame is a two-dimensional image.</li>
<li><strong>min_size</strong> (<em>-</em>) &#8211; removed. Passing zero (default) will result in no effect.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><em>- A boolean mask with the same shape as the last two dimensions of</em></li>
<li><cite>frames</cite> where True pixels are likely to be background material.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.particle_labels">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">particle_labels</code><span class="sig-paren">(</span><em>frames: numpy.ndarray</em>, <em>energies: numpy.ndarray</em>, <em>edge</em>, <em>min_distance=20</em><span class="sig-paren">)</span></dt>
<dd><p>Prepare a map by segmenting the images into particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>frames</strong> (<em>-</em>) &#8211; energy. These will be merged and used for segmentation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.predict_edge">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">predict_edge</code><span class="sig-paren">(</span><em>energies</em>, <em>*params</em><span class="sig-paren">)</span></dt>
<dd><p>Defines the curve function that gets fit to the data for an
absorbance K-edge.</p>
<p>The predicted curve is a combination of a straight line (for
background), an arctan function (for the edge), and a gaussian
peak (for the whiteline).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>energies</strong> (<em>np.ndarray</em>) &#8211; Array with energy values to be predicted.</li>
<li><strong>*params</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em><em></em>) &#8211; The curve parameters that should be used for the
prediction. Their order is described by kedge_params variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>curve</strong> &#8211; The predicted absorbance values based on the input
parameters. Shape will match <cite>energies</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.register_correlations">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">register_correlations</code><span class="sig-paren">(</span><em>frames</em>, <em>reference</em>, <em>upsample_factor=10</em>, <em>desc='Registering'</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate the relative translation between the reference image and
a series of frames.</p>
<p>This uses phase correlation through scikit-image&#8217;s
<cite>register_translation</cite> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>np.ndarray</em>) &#8211; Array where the last two dimensions are (column, row) of images
to be registered.</li>
<li><strong>reference</strong> (<em>np.ndarray</em>) &#8211; Image frame against which to align the entries in <cite>frames</cite>.</li>
<li><strong>upsample_factor</strong> (<em>int</em><em>, </em><em>optional</em>) &#8211; Factor controls subpixel registration via scikit-image.</li>
<li><strong>desc</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Description for putting in the progress bar.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>translations</strong> &#8211; Array with same dimensions as 0-th axis of <cite>frames</cite> containing
(x, y) translations for each frame.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.register_template">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">register_template</code><span class="sig-paren">(</span><em>frames</em>, <em>reference</em>, <em>template</em>, <em>desc='Registering'</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate the relative translation between the reference image and
a series of frames.</p>
<p>This uses template cross correlation through scikit-image&#8217;s
<cite>match_template</cite> function.</p>
<p>The <cite>register_correlations</cite> algorithm is simpler to use in most
cases but sometimes results in unreasonable results; in those
cases, this method can be more reliable to achieve a first
approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>np.ndarray</em>) &#8211; Array where the last two dimensions are (column, row) of images
to be registered.</li>
<li><strong>reference</strong> (<em>np.ndarray</em>) &#8211; Image frame against which to align the entries in <cite>frames</cite>.</li>
<li><strong>template</strong> (<em>np.ndarray</em>) &#8211; A 2D array (smaller than frames and reference) that will be
identified in each frame and used for alignment.</li>
<li><strong>desc</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Description for putting in the progress bar.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>translations</strong> &#8211; Array with same dimensions as 0-th axis of <cite>frames</cite> containing
(x, y) translations for each frame.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.transform_images">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">transform_images</code><span class="sig-paren">(</span><em>data</em>, <em>transformations</em>, <em>out=None</em>, <em>mode='median'</em><span class="sig-paren">)</span></dt>
<dd><p>Takes image data and applies the given translation matrices.</p>
<p>It is assumed that the first dimension of <cite>data</cite> is the same as
the length of <cite>transformations</cite>. The transformation matrices can
be generated from translation, rotation and scale parameters via
the <code class="xref py py-meth docutils literal"><span class="pre">xanespy.xanes_math.transformation_matrics()</span></code>
function. Data will be written to <cite>out</cite> if given, otherwise
returned as a new array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>np.ndarray</em>) &#8211; Numeric array with frames to transform. Last two dimensions are
assumed to be (row, columns).</li>
<li><strong>transformations</strong> (<em>np.ndarray</em>) &#8211; A numeric array shaped compatibally with <cite>data</cite>. The last two
dimensions are assumed to be (3, 3) and each (3, 3) encodes a
transformation matrix for the corresponding frame in <cite>data</cite>.</li>
<li><strong>out</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) &#8211; A numeric array with same shape as <cite>data</cite> that will hold the
transformed data.</li>
<li><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Describes how to deal with edges. See scikit-image documentation
for options. Special value &#8220;median&#8221; (default), takes the median
pixel intensity of that frame and uses it as the constant value.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> &#8211; A new array with similar dimensions to <cite>data</cite> but with
transformations applied and converted to float datatype.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="xanespy.xanes_math.transformation_matrices">
<code class="descclassname">xanespy.xanes_math.</code><code class="descname">transformation_matrices</code><span class="sig-paren">(</span><em>translations=None</em>, <em>rotations=None</em>, <em>scales=None</em>, <em>center=(0</em>, <em>0)</em><span class="sig-paren">)</span></dt>
<dd><p>Takes array of operations and calculates (3, 3) transformation
matrices.</p>
<p>This function operates by calculating an AffineTransform similar
to that described in the scikit-image package.</p>
<p>All three arguments (<cite>translations</cite>, <cite>rotations</cite>, and <cite>scales</cite>,
should have shapes that are compatible with the frame data, though
this is not strictly enforced for now. Rotation will necessarily
have one less degree of freedom than translation/scale values.</p>
<p>Example Shapes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="21%" />
<col width="19%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Frames</th>
<th class="head">Translations</th>
<th class="head">Rotations</th>
<th class="head">Scales</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>(10, 48, 1024, 1024)</td>
<td>(10, 48, 2)</td>
<td>(10, 48, 1)</td>
<td>(10, 48, 2)</td>
</tr>
<tr class="row-odd"><td>(10, 48, 1024, 1024, 1024)</td>
<td>(10, 48, 3)</td>
<td>(10, 48, 2)</td>
<td>(10, 48, 3)</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>translations</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) &#8211; How much to move each axis (x, y[, z]).</li>
<li><strong>rotations</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) &#8211; How much to rotate around the origin (0, 0) pixel.</li>
<li><strong>center</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) &#8211; Where to set the origin of rotation. Default is the
first pixel (0, 0).</li>
<li><strong>scales</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) &#8211; How much to scale the image by in each dimension
(x, y[, z]).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_transforms</strong> &#8211; Resulting transformation matrices. Will have the same shape as the
input arrays but with the last dimension replaced by (3, 3).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-xanespy.xradia">
<span id="xanespy-xradia-module"></span><h2>xanespy.xradia module</h2>
<p>Tools for importing X-ray microscopy frames in formats produced by
Xradia instruments.</p>
<dl class="class">
<dt id="xanespy.xradia.XRMFile">
<em class="property">class </em><code class="descclassname">xanespy.xradia.</code><code class="descname">XRMFile</code><span class="sig-paren">(</span><em>filename</em>, <em>flavor: str</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Single X-ray micrscopy frame created using XRadia XRM format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> (<em>-</em>) &#8211; </li>
<li><strong>flavor</strong> (<em>-</em>) &#8211; choices are [&#8216;ssrl&#8217;, &#8216;aps&#8217;, &#8216;aps-old1&#8217;]. These choices should
line up with whatever is generated using the scripts in
beamlines moudles.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="xanespy.xradia.XRMFile.aps_old1_regex">
<code class="descname">aps_old1_regex</code><em class="property"> = re.compile('(\\d{8})_([a-zA-Z0-9_]+)_([a-zA-Z0-9]+)_(\\d{4}).xrm')</em></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.binning">
<code class="descname">binning</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close original XRM (ole) file on disk.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.endtime">
<code class="descname">endtime</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Retrieve a datetime object representing when this frame was
finished collecting. Duration is decided by exposure time of the frame
and the start time.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.energy">
<code class="descname">energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Beam energy in electronvoltes.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.image_data">
<code class="descname">image_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>TXM Image frame.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.image_dtype">
<code class="descname">image_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.image_shape">
<code class="descname">image_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.ole_value">
<code class="descname">ole_value</code><span class="sig-paren">(</span><em>stream</em>, <em>fmt=None</em><span class="sig-paren">)</span></dt>
<dd><p>Get arbitrary data from the ole file and convert from bytes.</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.print_ole">
<code class="descname">print_ole</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.sample_position">
<code class="descname">sample_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.starttime">
<code class="descname">starttime</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Retrieve a datetime object representing when this frame was
collected. Timezone is inferred from flavor (eg. ssrl -&gt; california
time).</p>
</dd></dl>

<dl class="method">
<dt id="xanespy.xradia.XRMFile.um_per_pixel">
<code class="descname">um_per_pixel</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Describe the size of a pixel in microns. If this is an SSRL frame,
the pixel size is dependent on energy. For APS frames, the pixel size
is uniform and assumes a 40m field-of-view.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-xanespy">
<span id="module-contents"></span><h2>Module contents</h2>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>